

.data
// types and global data here ======================================================================

// PS/2 FIFO address
.EQU REG_PS2_FIFO, 0xff200108 // &Fifo
.EQU FIFO_FIELD_NEXT, 0
.EQU FIFO_FIELD_BUFFERSIZE, 2

.align 1 // aligned because of a strh instruction in updateKeyboardState
	// let mut make = true; // see updateKeyboard State
	.byte 0x1
	// let mut extended = false; // see updateKeyboardState
	.byte 0x0
// Use the keyboardState label to refer to these registers
.EQU KEYBOARDSTATE_OFFSETFOR_MAKE, -2
.EQU KEYBOARDSTATE_OFFSETFOR_EXTENDED, -1

/*
struct KeyState {
	pressed: bit,
	changed: bit,
}
// each KeyState is one byte
*/
.EQU KEYSTATE_BITINDEXOF_PRESSED, 0
.EQU KEYSTATE_BITINDEXOF_CHANGED, 1

// let mut keyboardState: &[keyState; 8] = staticallocation;
keyboardState:
	.skip KEYBOARDSTATE_SIZE
.EQU KEYBOARDSTATE_INDEXOF_ESC, 0
.EQU KEYBOARDSTATE_INDEXOF_SPACE, 1
.EQU KEYBOARDSTATE_INDEXOF_ONE, 2
.EQU KEYBOARDSTATE_INDEXOF_TWO, 3
.EQU KEYBOARDSTATE_INDEXOF_W, 4
.EQU KEYBOARDSTATE_INDEXOF_A, 5
.EQU KEYBOARDSTATE_INDEXOF_S, 6
.EQU KEYBOARDSTATE_INDEXOF_D, 7
.EQU KEYBOARDSTATE_INDEXOF_I, 8
.EQU KEYBOARDSTATE_INDEXOF_J, 9
.EQU KEYBOARDSTATE_INDEXOF_K, 10
.EQU KEYBOARDSTATE_INDEXOF_L, 11
.EQU KEYBOARDSTATE_SIZE, 12

/*
type TextBuffer = [[u8; TEXT_WIDTH]; TEXT_HEIGHT]; // not a regular array;
// the row index can take up 6 bits, the column index can take up 7 bits
// Interpreting buffer as a pointer, the byte at (r, c) is at `buffer + r << 7 + c`.
// Give it a size of 0x2000 (1 << 13)
}
*/
.EQU TEXTBUFFER_ROWSHIFT, 1 << 7 // uint
.EQU TEXT_WIDTH, 80 // uint
.EQU TEXT_HEIGHT, 60 // uint

// text buffer address
.EQU TEXT_BUFFER, 0xc9000000 // &TextBuffer

/*
type PixBuffer = [[u16; PIX_WIDTH]; PIX_HEIGHT], // not a regular array;
// the row index can take up 8 bits, the column index can take up 9 bits
// Interpreting buffer as a pointer, the color at (r, c) is at `buffer + r << 10 + c << 1`.
// Give it a size of 1 << 18.
}
*/
.EQU PIX_WIDTH, 320 // uint
.EQU PIX_HEIGHT, 240 // uint
.EQU PIXBUFFER_SIZE, 1 << 18 // uint
.EQU PIXBUFFER_ROWSHIFT, 1 << 10

/*
struct PixStatus {
	// irrelvant fields here
	isSwapping: bit
}
// All we need to know is that it's a 32-bit register whose 0th bit holds the status of whether a
// swap is in progress.
*/
.EQU PIXSTATUS_BITINDEXOF_ISSWAPPING, 0

// VGA controller interface
.EQU REG_PIX_FRONTBUFFER, 0xff203020 // &&PixBuffer
.EQU REG_PIX_BACKBUFFER, 0xff203024 // &&PixBuffer
.EQU REG_PIX_STATUS, 0xff20302c // &PixStatus

// let bufferA: &PixBuffer = staticallocation;
.align 2 // aligned to word because of str instruction in clearVga
bufferA:
	.skip PIXBUFFER_SIZE

// let bufferB: &PixBuffer = staticallocation;
.align 2 // aligned to word because of str instruction in clearVga
bufferB:
	.skip PIXBUFFER_SIZE

/*
struct Entity {
	xPos: i16,
	yPos: i16,
	xVel: i8,
	yVel: i8,
}
*/
.EQU ENTITY_FIELD_XPOS, 0
.EQU ENTITY_FIELD_YPOS, 2
.EQU ENTITY_FIELD_XVEL, 4
.EQU ENTITY_FIELD_YVEL, 5
.EQU ENTITY_SIZE, 6

/*
struct Ship extends Entity {
	direction: i8,
	health: i8,
	maxHealth: i8,
	bulletSpeed: i8,
	bulletDamage: i8,
	currentFireCooldown: i8,
	fireRate: i8,
	maxSpeed: i8,
}
// ships have their anchor in the center
*/
.EQU SHIP_FIELD_DIRECTION, 6
.EQU SHIP_FIELD_HEALTH, 7
.EQU SHIP_FIELD_MAXHEALTH, 8
.EQU SHIP_FIELD_BULLETSPEED, 9
.EQU SHIP_FIELD_BULLETDAMAGE, 10
.EQU SHIP_FIELD_CURRENTFIRECOOLDOWN, 11
.EQU SHIP_FIELD_FIRERATE, 12
.EQU SHIP_FIELD_MAXSPEED, 13
.EQU SHIP_SIZE, 14

// let ship: Ship = staticallocation;
.align 1
ship:
	.hword 160, 120
	.byte 0, 0
	.byte 0
	.byte 10, 10, 5, 10, 0, 20, 5

/*
struct Bullet extends Entity {
	appearance: &Pixmap,
	damage: i8,
}
*/
.EQU BULLET_FIELD_DAMAGE, 6 // out of order so that appearance is properly aligned
.EQU BULLET_FIELD_APPEARANCE, 8
.EQU BULLET_SIZE, 12

/*
struct Csb<T> {
	elementSize: u32,
	capacity: u32,
	begin: u32,
	end: u32,
	data: [T; capacity], // variable length array
}
// Csb stands for "circular sparse buffer." The buffer is circular; an iterator that is incremented to
// equal the capacity will wrap around to the beginning of the array. The "sparse" comes from the
// fact that during iteration, some elements are skipped depending on if the word at byte 8 is 0.
// Therefore, T must be a type with at least size 12.
// Because of how the circular buffer works, the actual capacity is buff.capacity - 1.
// A full-capacity buffer would have the begin and end iterators at the same position, but that
// would actually indicate an empty buffer.
*/
.EQU CSB_FIELD_ELEMENTSIZE, 0
.EQU CSB_FIELD_CAPACITY, 4
.EQU CSB_FIELD_BEGIN, 8
.EQU CSB_FIELD_END, 12
.EQU CSB_FIELD_DATA, 16

// let bulletBuff: CircleBuff<Bullet> = staticallocation;
.align 2
bulletBuff:
	.word BULLET_SIZE
	.word 128
	.word 0
	.word 0
	.skip 128 * BULLET_SIZE

// let mut tick: u32 = 0;
.align 4
tick:
	.word 0

.text
// functions here ==================================================================================

/*
fn _start();
*/
.global _start
_start:
	// initialize stack pointer
	mov sp, #0x800000

	bl setUpDoubleBuffer

	// call main
	bl main

	// idk what to do if execution gets here so just do a useless loop
_start_uselessLoop:
	ror r0, r0, #1
	b _start_uselessLoop
// end _start

/*
fn main();
*/
main:
	push {r4, r5, lr}

	ldr r4, =REG_PIX_BACKBUFFER

main_loop:
	bl waitVsync

	ldr r0, [r4]
	bl renderFrame

	bl swapBuffers

	bl advanceFrame

	b main_loop

	pop {r4, r5, lr}
// end main

/*
advanceFrame: changes the game state to reflect the next frame

fn advanceFrame() {
	tick += 1;

	updateKeyboardState();
	processPlayerInput();
	// TODO move every entity in the game based on its velocity
	processCollisions();
}
*/
advanceFrame:
	push {r4-r6, lr}

	// advance tick
	ldr r0, =tick
	ldr r1, [r0]
	add r1, r1, #1
	str r1, [r0]

	bl updateKeyboardState

	bl processPlayerInput

	bl moveEntities

	// processCollisions();

	pop {r4-r6, pc}
// end advanceFrame

/*
processPlayerInput: changes the ship's velocity and direction based on WASD and IJKL states

processPlayerInput() {
	ship.direction = (keyboardState.L.pressed as i32) - (keyboardState.J.pressed as i32);

	let xMove = (keyboardState.D.pressed as i32) - (keyboardState.A.pressed as i32);
	if xMove != 0 {
		ship.xVel += xMove * 2;
		if ship.xVel > ship.maxSpeed {
			ship.xVel = ship.maxSpeed;
		} else if ship.xVel < -ship.maxSpeed {
			ship.xVel = -ship.maxSpeed;
		}
	} else {
		ship.xVel -= sign(ship.xVel);
	}

	if keyboardState.I.changed == true && keyboardState.I.pressed == true {
		spawnBullet(ship);
	}

	// TODO add firing bullets
}
*/
processPlayerInput:
	push {r4, lr}

	// r0 = ship
	ldr r0, =ship

	// r4 = keyboardState
	ldr r4, =keyboardState

	// ship.direction = (keyboardState.L.pressed as i32) - (keyboardState.J.pressed as i32);
	ldrb r1, [r4, #KEYBOARDSTATE_INDEXOF_L]
	and r1, r1, #0x1
	ldrb r2, [r4, #KEYBOARDSTATE_INDEXOF_J]
	and r2, r2, #0x1
	sub r1, r1, r2
	strb r1, [r0, #SHIP_FIELD_DIRECTION]

	// r1 = xMove
	ldrb r1, [r4, #KEYBOARDSTATE_INDEXOF_D]
	and r1, r1, #0x1
	ldrb r2, [r4, #KEYBOARDSTATE_INDEXOF_A]
	and r2, r2, #0x1
	sub r1, r1, r2

	// r2 = ship.xVel
	ldrsb r2, [r0, #ENTITY_FIELD_XVEL]

	// if xMove != 0
	cmp r1, #0
	beq processPlayerInput_dampenX

	add r2, r2, r1, lsl #1
	// r3 = ship.maxSpeed
	ldrb r3, [r0, #SHIP_FIELD_MAXSPEED]
	cmp r2, r3
	bgt processPlayerInput_exceededMaxXVel
	rsb r3, r3, #0
	cmp r2, r3
	bge processPlayerInput_withinXVel
processPlayerInput_exceededMaxXVel:
	mov r2, r3
processPlayerInput_withinXVel:

	b processPlayerInput_xVelCalcsDone
processPlayerInput_dampenX:

	// r3 = -sign(ship.xVel);
	cmp r2, #0
	movlt r3, #1
	movgt r3, #-1
	moveq r3, #0

	add r2, r2, r3

processPlayerInput_xVelCalcsDone:
	// restore ship.xVel to memory
	strb r2, [r0, #ENTITY_FIELD_XVEL]

	// r1 = yMove
	ldrb r1, [r4, #KEYBOARDSTATE_INDEXOF_S]
	and r1, r1, #0x1
	ldrb r2, [r4, #KEYBOARDSTATE_INDEXOF_W]
	and r2, r2, #0x1
	sub r1, r1, r2

	// r2 = ship.yVel
	ldrsb r2, [r0, #ENTITY_FIELD_YVEL]

	// if yMove != 0
	cmp r1, #0
	beq processPlayerInput_dampenY

	add r2, r2, r1, lsl #1
	// r3 = ship.maxSpeed
	ldrb r3, [r0, #SHIP_FIELD_MAXSPEED]
	cmp r2, r3
	bgt processPlayerInput_exceededMaxYVel
	rsb r3, r3, #0
	cmp r2, r3
	bge processPlayerInput_withinMaxYVel
processPlayerInput_exceededMaxYVel:
	mov r2, r3
processPlayerInput_withinMaxYVel:

	b processPlayerInput_yVelCalcsDone
processPlayerInput_dampenY:

	// r3 = -sign(ship.yVel):
	cmp r2, #0
	movlt r3, #1
	movgt r3, #-1
	moveq r3, #0

	add r2, r2, r3

processPlayerInput_yVelCalcsDone:
	// restore ship.yVel to memory
	strb r2, [r0, #ENTITY_FIELD_YVEL]

	// fire bullet
	ldrb r1, [r4, #KEYBOARDSTATE_INDEXOF_I]
	cmp r1, #3
	// r0 is already the ship address
	bleq spawnBullet

	pop {r4, pc}
// end processPlayerInput

/*
moveEntities: changes every entity's position based on their current velocity. The ship is prevented
from moving off the screen.

fn moveEntities() {
	moveEntityBounded(ship)

	// TODO move all the other entities in the game
	forEach(bulletBuff, moveEntity);
}
*/
moveEntities:
	push {lr}

	ldr r0, =ship
	bl moveEntityBounded

	ldr r0, =bulletBuff
	ldr r1, =moveEntityWithVoid
	bl forEach

	pop {pc}
// end moveEntities

/*
moveEntityWithVoid: updates the specified Entity's position based on its current velocity. Also
kills the entity (sets the word at byte 8 to 0) if the entity is too far off the screen. This implies
that the entity must have a size of at least 12.

fn moveEntityWithVoid(entity: &Entity) {
	let tolerance = 32;
	entity.xPos += entity.xVel;
	if entity.xPos > PIX_WIDTH + tolerance || entity.xPos < -tolerance {
		isDead(entity) = true; // set the word at byte 8 to 0
		return;
	}

	entity.yPos += entity.yVel;
	if entity.yPos > PIX_HEIGHT + tolerance || entity.yPos < -tolerance {
		isDead(entity) = true; // set the word at byte 8 to 0
	}
}
*/
.EQU MOVEENTITYWITHVOID_TOLERANCE, 32
moveEntityWithVoid:
	// r0 = entity

	// r1 = entity.xPos
	ldrh r1, [r0, #ENTITY_FIELD_XPOS]
	ldrsb r2, [r0, #ENTITY_FIELD_XVEL]
	add r1, r1, r2
	strh r1, [r0, #ENTITY_FIELD_XPOS]

	cmp r1, #(PIX_WIDTH + MOVEENTITYWITHVOID_TOLERANCE)
	bge moveEntityWithVoid_kill
	cmp r1, #-MOVEENTITYWITHVOID_TOLERANCE
	blt moveEntityWithVoid_kill

	ldrh r1, [r0, #ENTITY_FIELD_YPOS]
	ldrsb r2, [r0, #ENTITY_FIELD_YVEL]
	add r1, r1, r2
	strh r1, [r0, #ENTITY_FIELD_YPOS]

	cmp r1, #(PIX_HEIGHT + MOVEENTITYWITHVOID_TOLERANCE)
	bge moveEntityWithVoid_kill
	cmp r1, #-MOVEENTITYWITHVOID_TOLERANCE
	blt moveEntityWithVoid_kill

	b moveEntityWithVoid_done
moveEntityWithVoid_kill:
	mov r1, #0
	str r1, [r0, #8]

moveEntityWithVoid_done:
	bx lr
// end moveEntity

/*
moveEntityBounded: updates the specified Entity's position based on its current velocity. Also
prevents the entity from moving off the screen

fn moveEntityBounded(entity: &Entity) {
	entity.xPos = max(0, min(PIX_WIDTH, entity.xVel));
	entity.yPos = max(0, min(PIX_HEIGHT, entity.yVel));
}
*/
moveEntityBounded:
	// r0 = entity

	ldrh r1, [r0, #ENTITY_FIELD_XPOS]
	ldrsb r2, [r0, #ENTITY_FIELD_XVEL]
	adds r1, r1, r2
	movlt r1, #0
	blt moveEntityBounded_doneCalculatingX
	cmp r1, #PIX_WIDTH
	movgt r1, #PIX_WIDTH
moveEntityBounded_doneCalculatingX:
	strh r1, [r0, #ENTITY_FIELD_XPOS]

	ldrh r1, [r0, #ENTITY_FIELD_YPOS]
	ldrsb r2, [r0, #ENTITY_FIELD_YVEL]
	adds r1, r1, r2
	movlt r1, #0
	blt moveEntityBounded_doneCalculatingY
	cmp r1, #PIX_HEIGHT
	movgt r1, #PIX_HEIGHT
moveEntityBounded_doneCalculatingY:
	strh r1, [r0, #ENTITY_FIELD_YPOS]

	bx lr
// end moveEntityBounded

/*
forEach: takes a Csb and applies the specified procedure to all elements that aren't skipped.
Also passes arg1 and arg2 to the procedure, if the procedure accepts them.
Also updates Csb.begin to reflect the first non-skipped element (or the end iterator, if there are
no non-skipped elements).

fn forEach(buff: &mut Csb<T>, procedure: fn (&mut T, Arg1, Arg2) -> void, arg1: Arg1, arg2: Arg2) {
	while buff.begin != buff.end && isDead(buff[buff.begin]) {
		buff.begin += 1; // using circular increments
	}
	for i in buff.begin..buff.end { // using circular increments
		if !isDead(buff[i]) {
			procedure(buff[i]);
		}
	}
}
*/
forEach:
	push {r4-r11, lr}

	// r0 = buff
	// r1 = procedure

	// r9 = procedure, r10 = arg1, r11 = arg2
	mov r9, r1
	mov r10, r2
	mov r11, r3

	// r4 = &buff.data, r5 = buff.elementSize, r6 = buff.begin, r7, = buff.end, r8 = buff.capacity
	ldr r5, [r0, #CSB_FIELD_ELEMENTSIZE]
	ldr r6, [r0, #CSB_FIELD_BEGIN]
	ldr r7, [r0, #CSB_FIELD_END]
	ldr r8, [r0, #CSB_FIELD_CAPACITY]
	add r4, r0, #(CSB_FIELD_DATA + 8)
	// r4 = buff.data + 8 bytes temporarily to make it easier to access the word at byte 8
	// It goes back to normal after the while loop

	// r0 = word at byte 8 of buff.data[buff.begin]
	b forEach_skipDeadCond
forEach_skipDeadBody:
	add r6, r6, #1
	cmp r6, r8
	movge r6, #0
forEach_skipDeadCond:
	cmp r6, r7
	beq forEach_skipDeadDone
	mla r0, r6, r5, r4
	ldr r0, [r0]
	cmp r0, #0
	beq forEach_skipDeadBody
forEach_skipDeadDone:
	// restore r4 = &buff.data
	sub r4, r4, #8

	// restore buff.begin to memory
	str r6, [r4, #(CSB_FIELD_BEGIN - CSB_FIELD_DATA)]

	// r6 = i
	b forEach_operateCond
forEach_operateBody:

	mla r0, r6, r5, r4 // r0 = &buff[i]
	ldr r1, [r0, #8] // r1 = word at byte 8 of buff[i]
	cmp r1, #0
	beq forEach_skipElement
	mov r1, r10
	mov r2, r11
	blx r9
forEach_skipElement:

	add r6, r6, #1
	cmp r6, r8
	movge r6, #0
forEach_operateCond:
	cmp r6, r7
	bne forEach_operateBody

	pop {r4-r11, pc}
// end forEach

/*
addSpace: allocates an additional space in the specified Csb and returns a pointer to the space.
The pointer points to uninitialized memory.
WARNING: assumes that there is enough space in the buffer to do this.

fn addSpace(buff: &mut Csb<T>) -> &mut T {
	let oldEnd = buff.end;
	buff.end += 1; // circular increment
	return &buff.data[oldEnd];
}
*/
addSpace:
	// r0 = buff.elementSize, r1 = &buff.data, r2 = oldEnd, r3 = buff.capacity,
	ldr r2, [r0, #CSB_FIELD_END]
	ldr r3, [r0, #CSB_FIELD_CAPACITY]
	add r1, r0, #CSB_FIELD_DATA
	ldr r0, [r1, #(CSB_FIELD_ELEMENTSIZE - CSB_FIELD_DATA)]

	// r0 = buff.data[oldEnd]
	mla r0, r2, r0, r1

	// r2 = buff.end
	add r2, r2, #1
	cmp r2, r3
	movge r2, #0
	str r2, [r1, #(CSB_FIELD_END - CSB_FIELD_DATA)]

	bx lr
// end addSpace

/*
spawnBullet(ship: &Ship) {
	let bullet: &mut Bullet = addSpace(&mut bulletBuff);
	bullet.xPos = ship.xPos;
	bullet.yPos = ship.yPos;
	bullet.xVel = ship.direction * ship.bulletSpeed;
	bullet.yVel = -ship.bulletSpeed;
	bullet.appearance = bulletSkinArray[ship.direction + 1];
	bullet.damage = ship.bulletDamage;
}
*/
spawnBullet:
	push {r4-r8, lr}
	// r0 = ship

	// r4 = ship.xPos, r5 = ship.yPos, r6 = ship.direction, r7 = ship.bulletDamage, r8 = ship.bulletSpeed
	ldrsh r4, [r0, #ENTITY_FIELD_XPOS]
	ldrsh r5, [r0, #ENTITY_FIELD_YPOS]
	ldrsb r6, [r0, #SHIP_FIELD_DIRECTION]
	ldrsb r7, [r0, #SHIP_FIELD_BULLETDAMAGE]
	ldrsb r8, [r0, #SHIP_FIELD_BULLETSPEED]

	// r0 = bullet
	ldr r0, =bulletBuff
	bl addSpace

	strh r4, [r0, #ENTITY_FIELD_XPOS]

	strh r5, [r0, #ENTITY_FIELD_YPOS]

	mul r1, r6, r8
	strb r1, [r0, #ENTITY_FIELD_XVEL]

	rsb r1, r8, #0
	strb r1, [r0, #ENTITY_FIELD_YVEL]

	strb r7, [r0, #BULLET_FIELD_DAMAGE]

	ldr r1, =bulletSkinArray
	add r2, r6, #1
	ldr r1, [r1, r2, lsl #2]
	str r1, [r0, #BULLET_FIELD_APPEARANCE]

	pop {r4-r8, pc}
// end spawnBullet

/*
updateKeyboardState: updates the keyboardState struct to reflect the current state of the keyboard.
Cannot handle pause key.

fn updateKeyboardState() {
	let static mut extended = false;
	let static mut make = true; // assume it's a make scan code unless a break code is encountered
	for keyState in keyboardState {
		keyState.changed = false;
	}
	while REG_PS2_FIFO.bufferSize > 0 {
		let scanCode = REG_PS2_FIFO.nextScanCode();
		match scanCode {
			0xf0 => make = false,
			0xe0 => extended = true,
			scanCode => {
				let keyIndex = if extended {
					match code {
						_ => goto resetFlags;
					}
				} else {
					match code {
						0x16 => KEYBOARDSTATE_INDEXOF_ONE,
						0x1e => KEYBOARDSTATE_INDEXOF_TWO,
						0x29 => KEYBOARDSTATE_INDEXOF_SPACE,
						0x76 => KEYBOARDSTATE_INDEXOF_ESC,
						0x1d => KEYBOARDSTATE_INDEXOF_W,
						0x1c => KEYBOARDSTATE_INDEXOF_A,
						0x1b => KEYBOARDSTATE_INDEXOF_S,
						0x23 => KEYBOARDSTATE_INDEXOF_D,
						0x43 => KEYBOARDSTATE_INDEXOF_I,
						0x3b => KEYBOARDSTATE_INDEXOF_J,
						0x42 => KEYBOARDSTATE_INDEXOF_K,
						0x4b => KEYBOARDSTATE_INDEXOF_L,
						_ => goto resetFlags;
					}
				};
				keyboardState[keyIndex].changed = keyboardState[offset].pressed != make;
				keyboardState[keyIndex].pressed = make;
				resetFlags:
				make = true;
				extended = false;
			},
		}
	}
}
*/
updateKeyboardState:
	push {r4}

	// r0's usage is quite volatile

	// r1 = keyboardState
	ldr r1, =keyboardState

	// iterate over keyState
	mov r2, #KEYBOARDSTATE_SIZE
	b updateKeyboardState_clearChangedCond
updateKeyboardState_clearChangedBody:

	// keyboardState[r2].changed = false;
	ldrb r0, [r1, r2]
	bic r0, r0, #(1 << KEYSTATE_BITINDEXOF_CHANGED)
	strb r0, [r1, r2]

updateKeyboardState_clearChangedCond:
	subs r2, r2, #1
	bge updateKeyboardState_clearChangedBody

	// r2 = REG_PS2_FIFO
	ldr r2, =REG_PS2_FIFO

	b updateKeyboardState_processCodesCond
updateKeyboardState_processCodesBody:

	// r3 = scanCode
	ldrb r3, [r2, #FIFO_FIELD_NEXT]

	// outer match statement
	cmp r3, #0xf0
	beq updateKeyboardState_codeBreak
	cmp r3, #0xe0
	beq updateKeyboardState_codeExtended

	// r3 = keyIndex
	ldrb r0, [r1, #KEYBOARDSTATE_OFFSETFOR_EXTENDED]
	cmp r0, #0
	bne updateKeyboardState_checkExtendedCodes
	cmp r3, #0x29
	moveq r3, #KEYBOARDSTATE_INDEXOF_SPACE
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x76
	moveq r3, #KEYBOARDSTATE_INDEXOF_ESC
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x16
	moveq r3, #KEYBOARDSTATE_INDEXOF_ONE
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x1e
	moveq r3, #KEYBOARDSTATE_INDEXOF_TWO
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x1d
	moveq r3, #KEYBOARDSTATE_INDEXOF_W
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x1c
	moveq r3, #KEYBOARDSTATE_INDEXOF_A
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x1b
	moveq r3, #KEYBOARDSTATE_INDEXOF_S
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x23
	moveq r3, #KEYBOARDSTATE_INDEXOF_D
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x43
	moveq r3, #KEYBOARDSTATE_INDEXOF_I
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x3b
	moveq r3, #KEYBOARDSTATE_INDEXOF_J
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x42
	moveq r3, #KEYBOARDSTATE_INDEXOF_K
	beq updateKeyboardState_keyIndexFound
	cmp r3, #0x4b
	moveq r3, #KEYBOARDSTATE_INDEXOF_L
	beq updateKeyboardState_keyIndexFound
	b updateKeyboardState_resetFlags
updateKeyboardState_checkExtendedCodes:
	b updateKeyboardState_resetFlags
updateKeyboardState_keyIndexFound:

	// r4 = keyboardState[keyIndex]
	ldrb r4, [r1, r3]
	ldrb r0, [r1, #KEYBOARDSTATE_OFFSETFOR_MAKE]
	add r4, r4, r0
	add r4, r0, r4, lsl #1
	and r4, r4, #((1 << KEYSTATE_BITINDEXOF_CHANGED) + (1 << KEYSTATE_BITINDEXOF_PRESSED)) // discard useless bits
	strb r4, [r1, r3]

updateKeyboardState_resetFlags:
	mov r0, #1 // hword representing both make and extended flags
	strh r0, [r1, #-2]

	b updateKeyboardState_processCodesCond
updateKeyboardState_codeBreak:

	// make = false
	mov r0, #0
	strb r0, [r1, #KEYBOARDSTATE_OFFSETFOR_MAKE]

	b updateKeyboardState_processCodesCond
updateKeyboardState_codeExtended:

	// extended = true
	mov r0, #1
	strb r0, [r1, #KEYBOARDSTATE_OFFSETFOR_EXTENDED]

updateKeyboardState_processCodesCond:
	// r3 = bufferSize
	ldrb r3, [r2, #FIFO_FIELD_BUFFERSIZE]
	cmp r3, #0
	bne updateKeyboardState_processCodesBody

	pop {r4}
	bx lr
// end updateKeyboardState

/*
fn renderFrame(buffer: &PixBuffer) {
	clearVga();

	// TODO draw all the entities
	forEach(bulletBuff, renderBullet, buffer);

	// draw player
	bitBlit(buffer, (*shipSkinArray)[ship.direction + 1], ship.xPos, ship.yPos)

	clearTextBuffer();
	drawNum(0, 0, tick);
	drawStr(15, 10, "Pushbuttons: up/down/left/right. Keep the ball up!");
}
*/
renderFrame:
	push {r4-r7, lr}
	// r0 = buffer

	// r4 = buffer
	mov r4, r0

	// clearVga();
	// r0 is already the buffer address
	ldr r1, =0x0
	bl clearVga

	// forEach(bulletBuff, renderBullet, buffer);
	ldr r0, =bulletBuff
	ldr r1, =renderBullet
	mov r2, r4
	bl forEach

	// draw Player
	mov r0, r4
	ldr r3, =ship
	ldrsb r2, [r3, #SHIP_FIELD_DIRECTION]
	add r2, r2, #1
	ldr r1, =shipSkinArray
	ldr r1, [r1, r2, lsl #2]
	ldrh r2, [r3, #ENTITY_FIELD_XPOS]
	ldrh r3, [r3, #ENTITY_FIELD_YPOS]
	bl bitBlit

	bl clearTextBuffer

	// drawNum(0, 0, tick)
	mov r0, #0
	mov r1, #0
	ldr r2, =tick
	ldr r2, [r2]
	bl drawNum

	// drawStr(...)
	mov r0, #15
	mov r1, #10
	ldr r2, =helpMessage
	bl drawStr
.data
helpMessage:
	.asciz "Use WASD to move. Keep the ball up!"
.text

	pop {r4-r7, pc}
// end renderFrame

/*
fn renderBullet(bullet: &Bullet, buffer: &PixBuffer) {
	bitBlit(buffer, bullet.appearance, bullet.xPos, bullet.yPos)
}
*/
renderBullet:
	push {lr}

	mov r3, r0
	mov r0, r1
	ldr r1, [r3, #BULLET_FIELD_APPEARANCE]
	ldrsh r2, [r3, #ENTITY_FIELD_XPOS]
	ldrsh r3, [r3, #ENTITY_FIELD_YPOS]
	bl bitBlit

	pop {pc}
// end renderBullet

/*
fn setUpDoubleBuffer();
*/
setUpDoubleBuffer:
	push {r4, lr}

	ldr r4, =REG_PIX_BACKBUFFER

	// put the buffer address into the backbuffer register
	ldr r0, =bufferA
	str r0, [r4]

	bl swapBuffers
	bl waitVsync

	// put the other buffer address into the backbuffer register
	ldr r0, =bufferB
	str r0, [r4]

	pop {r4, pc}
// end setUpDoubleBuffer

/*
swapBuffers: requests a buffer swap by writing 1 to the frontbuffer register
*/
swapBuffers:
	mov r0, #1
	ldr r1, =REG_PIX_FRONTBUFFER
	str r0, [r1]
	bx lr
// end swapBuffers

/*
waitVsync: blocks until vsync is finished
*/
waitVsync:
	ldr r0, =REG_PIX_STATUS
	ldr r0, [r0]
	and r0, r0, #(1 << PIXSTATUS_BITINDEXOF_ISSWAPPING)
	cmp r0, #0
	bne waitVsync
	bx lr
// end waitVsync

/*
clearVga: fills the video buffer with the specified color

fn clearVga(buffer: *PixBuffer, color: u16) {
	let color_pair: u32 = (color << 16) | color;
	for row in 0..240 {
		let buffer_row = buffer[row] as *u32; // expand size to write to 4-byte color pairs rather than 2-byte colors
		for col in 0..(320 / 2) { // col doesn't count pixels, but rather pixel pairs
			buffer[col] = colorpair;
		}
	}
}
*/
clearVga:
	// r1 = color
	// r0 = buffer_row (see outer loop's iteration expression)

	// r1 = colorpair
	orr r1, r1, r1, lsl #16

	// r2 = row
	mov r2, #0
	b clearVga_outerForCond
clearVga_outerForBody:

	// r3 = col
	mov r3, #0
	b clearVga_innerForCond
clearVga_innerForBody:

	str r1, [r0, r3, lsl #2] // storing into a u32 array

	add r3, r3, #1
clearVga_innerForCond:
	cmp r3, #(PIX_WIDTH / 2)
	blo clearVga_innerForBody

	add r2, r2, #1
	add r0, r0, #PIXBUFFER_ROWSHIFT // update pointer to new row
clearVga_outerForCond:
	cmp r2, #PIX_HEIGHT
	blo clearVga_outerForBody

	bx lr
// end clearVga

/*
clearTextBuffer: Fills the text buffer with spaces (ASCII 32)

fn clearTextBuffer() {
	for row in 0..60 {
		let buffer_row = TEXT_BUFFER[row];
		for col in (0..80).step(4) {
			// expand size to write 4-byte strings rather than single byte characters
			*(buffer_row[col] as *u32) = 0x20202020;
		}
	}
}
*/
clearTextBuffer:
	// r0 = buffer_row (see outer loop's iteration expression)
	mov r0, #TEXT_BUFFER

	// r1 = 0x20202020
	ldr r1, =0x20202020

	// r2 = row
	mov r2, #0
	b clearTextBuffer_outerForCond
clearTextBuffer_outerForBody:

	// r3 = col
	mov r3, #0
	b clearTextBuffer_innerForCond
clearTextBuffer_innerForBody:

	str r1, [r0, r3]

	add r3, r3, #4
clearTextBuffer_innerForCond:
	cmp r3, #TEXT_WIDTH
	blo clearTextBuffer_innerForBody

	add r2, r2, #1
	add r0, r0, #TEXTBUFFER_ROWSHIFT // update pointer to new row
clearTextBuffer_outerForCond:
	cmp r2, #TEXT_HEIGHT
	blo clearTextBuffer_outerForBody

	bx lr
// end clearTextBuffer

/*
bitBlit: Draws the specified Pixmap into the VGA buffer, centered at the specified x and y
coordinates. If the image goes past the VGA screen boundaries, pixels are not drawn.

fn bitBlit(buffer: *PixBuffer, p: *Pixmap, x: i32, y: i32) {
	// convert center coordinates to top left corner coordinates
	let y = y - p.height >> 1;
	let x = x - p.width >> 1;

	// find the portion of the pixmap to draw
	let start_row = max(0, -y);
	let start_col = max(0, -x);
	let end_row = min(p.height, PIX_HEIGHT - y);
	let end_col = min(p.width, PIX_WIDTH - x);

	for row in start_row..end_row {
		let buffer_row: *u16 = (buffer[y + row] + x) as *u16;
		for col in start_col..end_col {
			let pixel = p.pixeldata[row * p.width + col];
			if pixel != p.transparency {
				buffer[col] = pixel;
			}
		}
	}
}
*/
bitBlit:
	push {r4-r9, lr}

	// r0 = buffer
	// r1 = p
	// r2 = x
	// r3 = y

	// r4 = p.width
	ldrh r4, [r1, #PIXMAP_FIELD_WIDTH]

	// r5 = p.height
	ldrh r5, [r1, #PIXMAP_FIELD_HEIGHT]

	// r2 = x
	sub r2, r2, r4, lsr #1

	// r3 = y
	sub r3, r3, r5, lsr #1

	// r6 = start_col
	rsb r6, r2, #0
	cmp r6, #0
	bgt bitBlit_1
	mov r6, #0
bitBlit_1:

	// r7 = start_row
	rsb r7, r3, #0
	cmp r7, #0
	bgt bitBlit_0
	mov r7, #0
bitBlit_0:

	// r8 = end_col
	rsb r8, r2, #PIX_WIDTH
	cmp r8, r4
	blt bitBlit_3
	mov r8, r4
bitBlit_3:

	// r9 = end_row
	rsb r9, r3, #PIX_HEIGHT
	cmp r9, r5
	blt bitBlit_2
	mov r9, r5
bitBlit_2:

	// From here on, horizontal coordinates are double what they are in the pseudocode, for ease of
	// fetching the halfword values.
	lsl r2, r2, #1
	lsl r4, r4, #1
	lsl r8, r8, #1
	// skip doubling r6 because it gets reset anyway

	// r0 = PIX_BUFFER[y + start_row] + x
	add r0, r0, r3, lsl #10
	add r0, r0, r7, lsl #10
	add r0, r0, r2

	// r3 = p.transparency
	ldrh r3, [r1, #PIXMAP_FIELD_TRANSPARENCY]

	// r1 = p.pixeldata
	add r1, #PIXMAP_FIELD_PIXELDATA

	// r2 = start_col
	lsl r2, r6, #1

	// r7 = row
	// r6 = col

	// outer for loop
	b bitBlit_outerCond
bitBlit_outerBody:

	// r0 = buffer_row (see loop's iteration expression)

	// inner for loop
	mov r6, r2
	b bitBlit_innerCond
bitBlit_innerBody:

	// r5 = pixel
	mla r5, r7, r4, r6
	ldrh r5, [r1, r5]

	// maybe draw pixel
	cmp r5, r3
	beq bitBlit_skipDraw
	strh r5, [r0, r6]
bitBlit_skipDraw:

	add r6, r6, #2
bitBlit_innerCond:
	cmp r6, r8
	blt bitBlit_innerBody

	add r0, r0, #0x400 // update pointer to new row (0x400 is 1 << 10)
	add r7, r7, #1
bitBlit_outerCond:
	cmp r7, r9
	blt bitBlit_outerBody

	pop {r4-r9, pc}
// end bitBlit

/*
drawStr: draws a null-terminated string into the character buffer

fn drawStr(x: uint, y: uint, str: *char) {
	let bufferRow: [u8; TEXT_WIDTH] = TEXT_BUFFER[y];
	let mut col = x;
	let mut p = str;
	while x < TEXT_WIDTH && *p != '\0' {
		bufferRow[col] = *p;
		col += 1;
		p += 1;
	}
}
*/
drawStr:
	// r0 = x
	// r1 = y
	// r2 = str

	// r1 = bufferRow
	lsl r1, r1, #7
	add r1, r1, #TEXT_BUFFER

	// r0 = col
	// r3 = *p
	b drawStr_cond
drawStr_loop:

	strb r3, [r1, r0]
	add r0, r0, #1
	add r2, r2, #1

drawStr_cond:
	cmp r0, #TEXT_WIDTH
	bhs drawStr_end
	ldrb r3, [r2]
	cmp r3, #0
	bne drawStr_loop

drawStr_end:
	bx lr
// end drawStr

/*
drawNum: draws a signed integer into the character buffer

fn drawNum(x: uint, y: uint, num: i32) {
	let mut remainingDigits = num;
	let mut buffer: [u8; 12]; // max int is 10 decimal digits, plus two for null terminator and minus
	let mut = 11; // index to the first element of the array
	buffer[index] = '\0';

	// add digits to buffer
	if num == 0 {
		index -= 1;
		buffer[index] = '0';
	} else {
		// handle negative
		if num < 0 {
			remainingDigits = -remainingDigits;
		}

		// extract digits
		let mut rem;
		// write to the array from right to left
		while remainingDigits > 0 {
			(remainingDigits, rem) = divTenRem(remainingDigits);
			index -= 1;
			buffer[index] = toAscii(rem);
		}

		if num < 0 {
			index -= 1;
			buffer[index] = '-';
		}
	}

	// print buffer
	drawStr(x, y, (buffer as *u8) + index);
}
*/
drawNum:
	push {r4-r7, lr}

	// sp = buffer
	sub sp, sp, #12

	// r4 = x, r5 = y, r6 = num, r7 = index
	mov r4, r0
	mov r5, r1
	mov r6, r2
	mov r7, #11

	// buffer[index] = '\0';
	mov r0, #0
	strb r0, [sp, r7]

	// r0 = num, r0 = remainingDigits
	movs r0, r2

	// handle zero
	beq drawNum_isZero

	// handle negative possibility
	rsblt r0, r0, #0

	// extract digits
	b drawNum_cond
drawNum_loop:

	// r0 = remainingDigits, r1 = rem
	bl divTenRem
	sub r7, r7, #1
	add r1, r1, #48 // r1 = toAscii(rem)
	strb r1, [sp, r7]

drawNum_cond:
	cmp r0, #0
	bhi drawNum_loop

	// maybe add minus sign
	cmp r6, #0
	bge drawNum_skipMinusSign
	sub r7, r7, #1
	mov r1, #45 // r1: '-'
	strb r1, [sp, r7]
drawNum_skipMinusSign:

	b drawNum_print
drawNum_isZero:
	sub r7, r7, #1
	mov r1, #48 // r1 = '0'
	strb r1, [sp, r7]

drawNum_print:
	mov r0, r4
	mov r1, r5
	add r2, sp, r7
	bl drawStr

	add sp, sp, #12 // deallocate array of 12 bytes
	pop {r4-r7, pc}
// end drawNum

/*
divTenRemSmall: divides an unsigned number by 10, returning its quotient and remainder. Will not
work for numbers larger than about 6.7e8.
Algorithm for dividing by 10 credited to:
Vowels, R. A. (1992). "Division by 10". Australian Computer Journal. 24 (3): 81–85.

fn divTenRemSmall(dividend: i32) -> (quotient: i32, remainder: i32);
*/
divTenRemSmall:
	mov r1, r0 // save the divident for later

	// divide r0 by 10
	add r0, r0, #1
	lsl r0, r0, #1
	add r0, r0, r0, lsl #1
	add r0, r0, r0, lsr #4
	add r0, r0, r0, lsr #8
	add r0, r0, r0, lsr #16
	lsr r0, r0, #6

	// subtract quotient * 10 from the dividend to get remainder
	sub r1, r1, r0, lsl #3 // divident - 8 * quotient
	sub r1, r1, r0, lsl #1 // divident - 8 * quotient - 2 * quotient

	bx lr
// end divTenRemSmall

/*
divTenRem: divides an unsigned number by 10, returning its quotient and remainder. Will work for any
unsigned 32-bit number, unlike divTenRemSmall.

fn divTenRem(dividend: i32) -> (quotient: i32, remainder: i32){
	if (dividend <= 0x10000000) { // 28 bits is safely below the maximum valid input for divTenRemSmall
		return divTenRemSmall(dividend);
	}
	int msn = dividend & 0xf0000000; // "most significant nybble"
	int rest = dividend - msn;
	msn >>= 4;
	(int msnQuot, int msnRem) = divTenRemSmall(msn);
	msnQuot <<= 4;
	rest += msnRem << 4;
	(int restQuot, int restRem) = divTenRemSmall(rest);
	return (msnQuot + restQuot, restRem);
}
*/
divTenRem:
	// r0: dividend
	cmp r0, #0x10000000
	bhi divTenRem_continue
	push {lr}
	bl divTenRemSmall
	pop {pc}

	divTenRem_continue:
	push {r4, r5, lr}
	and r4, r0, #0xf0000000 // r4: msn
	sub r5, r0, r4 // r5: rest
	lsr r0, r4, #4 // r0: msn
	bl divTenRemSmall // r0: msnQuot, r1: msnRem
	lsl r4, r0, #4 // r4: msnQuot
	add r0, r5, r1, lsl $4 // r0: rest
	bl divTenRemSmall // r0: restQuot, r1: restRem
	add r0, r0, r4 // r0: msnQuot + restQuot
	pop {r4, r5, pc}
// end divTenRem

.data
// game assets and data here =======================================================================

/*
struct Pixmap {
	width: u16,
	height: u16,
	transparency: u16,
	pixelData: [u16; width * height], // variable-length struct
}
*/
.EQU PIXMAP_FIELD_WIDTH, 0
.EQU PIXMAP_FIELD_HEIGHT, 2
.EQU PIXMAP_FIELD_TRANSPARENCY, 4
.EQU PIXMAP_FIELD_PIXELDATA, 6

.align 2
// let mut shipSkinArray: [&Pixmap; 3];
shipSkinArray:
	.long shipSkinLeft
	.long shipSkinForward
	.long shipSkinRight

.align 1
shipSkinForward:
	.hword 32, 32, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x820, 0x1040, 0xf746, 0xf746, 0x1040, 0x820, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x820, 0xef29, 0xf765, 0xf765, 0xef29
	.hword 0x820, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x1040, 0xef49, 0xef64, 0xef61
	.hword 0xef61, 0xef64, 0xef49, 0x1040, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x820, 0xef08, 0xf743
	.hword 0xf761, 0xf780, 0xf780, 0xf761, 0xf743, 0xef08, 0x820, 0x20, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1040, 0xf748
	.hword 0xf744, 0xf761, 0xf7a1, 0xf780, 0xf780, 0xf7a1, 0xf761, 0xf744, 0xf748, 0x1040
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x820
	.hword 0xef28, 0xf722, 0xf741, 0xff80, 0xf740, 0xf780, 0xff80, 0xf740, 0xff80, 0xf741
	.hword 0xf723, 0xef28, 0x820, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x1040, 0xef28, 0xf764, 0xf761, 0xff60, 0xff60, 0xff80, 0xf760, 0xf760, 0xff80
	.hword 0xff60, 0xff60, 0xf761, 0xf764, 0xef28, 0x1040, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x820, 0xef28, 0xf763, 0xf740, 0xff80, 0xff60, 0xff60, 0xff60, 0xff60
	.hword 0xff60, 0xff60, 0xff60, 0xf760, 0xff80, 0xf740, 0xf763, 0xef28, 0x820, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x1040, 0xef28, 0xf743, 0xf761, 0xf760, 0xf760, 0xf760, 0xf760
	.hword 0xff60, 0xff60, 0xff60, 0xff60, 0xf760, 0xf780, 0xf760, 0xf760, 0xf761, 0xf743
	.hword 0xef28, 0x1040, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x820, 0xef28, 0xff63, 0xf761, 0xf760, 0xf760, 0xf780
	.hword 0xf780, 0xf760, 0xff60, 0xff60, 0xff60, 0xff60, 0xf760, 0xf780, 0xf780, 0xf760
	.hword 0xf760, 0xf761, 0xff63, 0xef28, 0x820, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x0, 0x0, 0x1040, 0xf749, 0xf743, 0xf741, 0xf760, 0xf760
	.hword 0xf780, 0xf780, 0xf760, 0xf760, 0xff60, 0xff60, 0xff60, 0xff60, 0xf760, 0xf760
	.hword 0xf780, 0xf780, 0xf760, 0xf760, 0xf741, 0xf743, 0xf749, 0x1040, 0x0, 0x0
	.hword 0x20, 0x0, 0x0, 0x0, 0x0, 0x820, 0xef08, 0xf743, 0xf761, 0xff60
	.hword 0xf760, 0xf780, 0xf780, 0xf780, 0xf760, 0xff60, 0xff60, 0xff60, 0xff60, 0xff60
	.hword 0xff60, 0xf760, 0xf760, 0xf780, 0xf780, 0xf760, 0xff60, 0xf760, 0xf743, 0xef08
	.hword 0x820, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1040, 0xf749, 0xf744, 0xf741
	.hword 0xff81, 0xf760, 0xf760, 0xf780, 0xf760, 0xf760, 0xff60, 0xff60, 0xf760, 0xf760
	.hword 0xf760, 0xf760, 0xff60, 0xff60, 0xf760, 0xf760, 0xf780, 0xf780, 0xff60, 0xff81
	.hword 0xf741, 0xf744, 0xf749, 0x1040, 0x0, 0x0, 0x800, 0x820, 0xef28, 0xf743
	.hword 0xf761, 0xff80, 0xf740, 0xff80, 0xf760, 0xf760, 0xf760, 0xff60, 0xff60, 0xff60
	.hword 0xf760, 0xf780, 0xf760, 0xf760, 0xff60, 0xff60, 0xff60, 0xf760, 0xf760, 0xf760
	.hword 0xff80, 0xf740, 0xff80, 0xf761, 0xf743, 0xef28, 0x820, 0x800, 0x1040, 0xef28
	.hword 0xf784, 0xf781, 0xf780, 0xf780, 0xff80, 0xff60, 0xff60, 0xff60, 0xff60, 0xff60
	.hword 0xf760, 0xf760, 0xf760, 0xf760, 0xff60, 0xf760, 0xf760, 0xf760, 0xff60, 0xff60
	.hword 0xff60, 0xff60, 0xff60, 0xff80, 0xf780, 0xf780, 0xf781, 0xf784, 0xef28, 0x1040
	.hword 0xf745, 0xf764, 0xef41, 0xf780, 0xf780, 0xf760, 0xf760, 0xff60, 0xff60, 0xff60
	.hword 0xff60, 0xff60, 0xf760, 0xf760, 0xf760, 0xff60, 0xff60, 0xf760, 0xf760, 0xf760
	.hword 0xff60, 0xff60, 0xff60, 0xff60, 0xff60, 0xf760, 0xf760, 0xf780, 0xf780, 0xef41
	.hword 0xf764, 0xf745, 0xf744, 0xf744, 0xf762, 0xf781, 0xf780, 0xf760, 0xff80, 0xf760
	.hword 0xff60, 0xff60, 0xff60, 0xff60, 0xff60, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760
	.hword 0xf760, 0xf760, 0xf760, 0xff60, 0xff60, 0xff60, 0xf760, 0xff80, 0xf760, 0xf760
	.hword 0xf761, 0xf742, 0xf744, 0xf744, 0x1860, 0xef29, 0xf749, 0xef27, 0xef46, 0xf786
	.hword 0xe704, 0xf766, 0xef46, 0xef46, 0xef47, 0xef27, 0xef47, 0xef46, 0xef46, 0xef46
	.hword 0xef46, 0xef46, 0xef46, 0xef47, 0xef47, 0xef47, 0xef46, 0xef46, 0xf766, 0xe704
	.hword 0xf786, 0xef46, 0xef27, 0xf749, 0xef29, 0x1840, 0x0, 0x20, 0x820, 0x20
	.hword 0x840, 0x20, 0x20, 0x840, 0x820, 0x820, 0x820, 0x820, 0x820, 0x820
	.hword 0x820, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	.hword 0x840, 0x20, 0x20, 0x840, 0x20, 0x820, 0x0, 0x800, 0x1, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0

.align 1
shipSkinLeft:
	.hword 32, 32, 0x800
	.hword 0x800, 0x800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x1, 0x801, 0x801, 0x801
	.hword 0x801, 0x0, 0x801, 0x0, 0x20, 0x40, 0x20, 0x0, 0x821, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x801, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40
	.hword 0x0, 0x20, 0x0, 0x20, 0x0, 0x0, 0x20, 0x20, 0x20, 0x40
	.hword 0x0, 0x0, 0x820, 0x820, 0x20, 0x20, 0x20, 0x20, 0x820, 0x820
	.hword 0x820, 0x820, 0x820, 0x820, 0x20, 0x20, 0x820, 0x820, 0x800, 0x800
	.hword 0x820, 0x20, 0x20, 0x20, 0x0, 0x0, 0x0, 0x41, 0x0, 0x0
	.hword 0x21, 0x0, 0x40, 0x820, 0x1040, 0x1880, 0x1080, 0x1080, 0x1060, 0x1060
	.hword 0x1060, 0x1080, 0x1060, 0x1060, 0x1880, 0x1880, 0x1880, 0x1880, 0x1880, 0x1880
	.hword 0x1880, 0x1860, 0x1860, 0x1060, 0x1060, 0x840, 0x0, 0x20, 0x0, 0x0
	.hword 0x20, 0x0, 0x0, 0x0, 0x840, 0xded5, 0xded1, 0xe70f, 0xe70f, 0xe70f
	.hword 0xe70f, 0xe6ef, 0xe6ef, 0xe70e, 0xe70f, 0xe70f, 0xe70f, 0xe70f, 0xef0f, 0xef0f
	.hword 0xef0f, 0xe70e, 0xef0f, 0xeeef, 0xeef0, 0xef12, 0xe6f3, 0x840, 0x840, 0x0
	.hword 0x0, 0x20, 0x0, 0x820, 0x0, 0x820, 0x1040, 0xded1, 0xef4c, 0xef28
	.hword 0xef27, 0xef47, 0xef27, 0xef47, 0xef47, 0xef46, 0xef47, 0xef47, 0xef47, 0xef27
	.hword 0xf727, 0xf728, 0xef27, 0xef27, 0xef27, 0xef28, 0xef07, 0xeee9, 0xef0c, 0xe6f1
	.hword 0x820, 0x820, 0x0, 0x40, 0x0, 0x0, 0x0, 0x820, 0x1080, 0xef2f
	.hword 0xf749, 0xf744, 0xf763, 0xf763, 0xf763, 0xf763, 0xf762, 0xf762, 0xf762, 0xf762
	.hword 0xf763, 0xf743, 0xf743, 0xf763, 0xf763, 0xef63, 0xef63, 0xef44, 0xf744, 0xf727
	.hword 0xef2c, 0xe6f1, 0x820, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x820
	.hword 0x1880, 0xe70e, 0xef27, 0xf763, 0xf762, 0xf761, 0xf761, 0xf761, 0xf761, 0xf761
	.hword 0xf761, 0xf761, 0xf761, 0xf761, 0xef40, 0xf781, 0xef81, 0xef81, 0xef41, 0xf763
	.hword 0xf746, 0xef0a, 0xe6f1, 0x840, 0x840, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x1080, 0xe70e, 0xef47, 0xf763, 0xf761, 0xf761, 0xf761, 0xf760
	.hword 0xf760, 0xf760, 0xf760, 0xf760, 0xff60, 0xf740, 0xf7a0, 0xef80, 0xef80, 0xf781
	.hword 0xf762, 0xf744, 0xef08, 0xef4f, 0x1060, 0x820, 0x20, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x20, 0x1080, 0xe70f, 0xef27, 0xf763, 0xf761, 0xf761
	.hword 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf7c1, 0xf7a0
	.hword 0xf760, 0xf781, 0xf743, 0xef28, 0xe72f, 0x860, 0x860, 0x40, 0x0, 0x1
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x1080, 0xe6ef, 0xef47, 0xf763
	.hword 0xf761, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf780, 0xf780
	.hword 0xf780, 0xef80, 0xf761, 0xf744, 0xf728, 0xef0d, 0x18a0, 0x40, 0x20, 0x0
	.hword 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x820, 0x1880, 0xe6ef
	.hword 0xef47, 0xf762, 0xf761, 0xf760, 0xf760, 0xf760, 0xff60, 0xff60, 0xff60, 0xf760
	.hword 0xf760, 0xf760, 0xf780, 0xf761, 0xf764, 0xef08, 0xeef0, 0x1040, 0x820, 0x0
	.hword 0x0, 0x0, 0x800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x820
	.hword 0x1880, 0xe70e, 0xef46, 0xf762, 0xf760, 0xf760, 0xf760, 0xf760, 0xff60, 0xff60
	.hword 0xff60, 0xf760, 0xf760, 0xff81, 0xf781, 0xef23, 0xef08, 0xef2f, 0x1020, 0x1040
	.hword 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0
	.hword 0x0, 0x820, 0x1880, 0xe70f, 0xef47, 0xf762, 0xf761, 0xf780, 0xf780, 0xf760
	.hword 0xff60, 0xff60, 0xff60, 0xf760, 0xf760, 0xf741, 0xf743, 0xf728, 0xef0f, 0x1040
	.hword 0x860, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1
	.hword 0x0, 0x0, 0x0, 0x820, 0x1080, 0xe70f, 0xef27, 0xf762, 0xf761, 0xf760
	.hword 0xf780, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf761, 0xf764, 0xf748, 0xef2d
	.hword 0x1040, 0x1060, 0x20, 0x0, 0x0, 0x0, 0x800, 0x0, 0x20, 0x0
	.hword 0x0, 0x1, 0x0, 0x0, 0x0, 0x20, 0x1880, 0xef0f, 0xef27, 0xf743
	.hword 0xf761, 0xff80, 0xf760, 0xf780, 0xf781, 0xf761, 0xf740, 0xf762, 0xef43, 0xef47
	.hword 0xef0e, 0x1840, 0x1040, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x20, 0x1880, 0xef0f
	.hword 0xef27, 0xf743, 0xff61, 0xf740, 0xf7a0, 0xf760, 0xf760, 0xff81, 0xf762, 0xf744
	.hword 0xef27, 0xf76d, 0x1860, 0x800, 0x800, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x820
	.hword 0x1880, 0xeeef, 0xef27, 0xf763, 0xf761, 0xf780, 0xf7a0, 0xf7a0, 0xf760, 0xf782
	.hword 0xf743, 0xef27, 0xef0e, 0x1040, 0x1020, 0x1020, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x820, 0x1880, 0xef0e, 0xef27, 0xf763, 0xf781, 0xf780, 0xf780, 0xf781
	.hword 0xf762, 0xf744, 0xf728, 0xef0d, 0x1880, 0x1000, 0x800, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x820, 0x1880, 0xe70e, 0xef47, 0xef62, 0xef61, 0xf760
	.hword 0xf780, 0xf762, 0xf765, 0xef08, 0xef0f, 0x1060, 0x1020, 0x800, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x1, 0x0, 0x0, 0x0, 0x820, 0x1880, 0xe70e, 0xef47, 0xf763
	.hword 0xf761, 0xf781, 0xf762, 0xef24, 0xef29, 0xef2f, 0x840, 0x1040, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x820, 0x1880, 0xe70e
	.hword 0xef27, 0xf743, 0xf762, 0xf721, 0xef23, 0xf748, 0xef10, 0x1040, 0x860, 0x20
	.hword 0x0, 0x20, 0x0, 0x0, 0x20, 0x0, 0x20, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20
	.hword 0x1880, 0xef0f, 0xef27, 0xf743, 0xf764, 0xf745, 0xf748, 0xef2e, 0x1040, 0x1040
	.hword 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0
	.hword 0x0, 0x20, 0x1040, 0xeef0, 0xf728, 0xf744, 0xef45, 0xef28, 0xe72e, 0x1060
	.hword 0x1040, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x20, 0x40, 0x1040, 0xef12, 0xeee9, 0xef27, 0xe709, 0xef4f
	.hword 0x1080, 0x840, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x880, 0x1040, 0xe6d3, 0xef0c, 0xef4c
	.hword 0xe711, 0x1040, 0x860, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1
	.hword 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x20, 0x0, 0x840, 0x1040
	.hword 0xe6f1, 0xe6f1, 0x1880, 0x820, 0x20, 0x20, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1
	.hword 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x801, 0x0, 0x0, 0x40
	.hword 0x20, 0x20, 0x840, 0x820, 0x820, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x801, 0x0
	.hword 0x0, 0x0, 0x40, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x1, 0x1, 0x0, 0x20, 0x0, 0x20, 0x0, 0x20, 0x0, 0x1
	.hword 0x0, 0x0, 0x0, 0x0, 0x21, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x1, 0x0, 0x0, 0x20, 0x20, 0x0, 0x20, 0x40, 0x0
	.hword 0x0, 0x0, 0x21, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x1
	.hword 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x1, 0x1

.align 1
shipSkinRight:
	.hword 32, 32, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x800, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x820, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x21, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0
	.hword 0x20, 0x20, 0x0, 0x0, 0x800, 0x800, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x20, 0x840, 0x820, 0x820, 0x820, 0x820, 0x840, 0x840
	.hword 0x840, 0x840, 0x840, 0x840, 0x820, 0x820, 0x820, 0x820, 0x840, 0x840
	.hword 0x820, 0x820, 0x1020, 0x820, 0x820, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x820, 0x840, 0xe70d, 0xef2b, 0xef2a, 0xef29, 0xef29
	.hword 0xef29, 0xef29, 0xef29, 0xef29, 0xef2a, 0xef2a, 0xef29, 0xef29, 0xef2a, 0xef2a
	.hword 0xef2a, 0xef2a, 0xef2a, 0xef2a, 0xef2a, 0xe6ec, 0xe711, 0x820, 0x0, 0x0
	.hword 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0xe70a, 0xef44, 0xf744, 0xf743
	.hword 0xf743, 0xf763, 0xf762, 0xf762, 0xf763, 0xf743, 0xf763, 0xf763, 0xf763, 0xf763
	.hword 0xf743, 0xf763, 0xf763, 0xf763, 0xf763, 0xf763, 0xf764, 0xf747, 0xe6ec, 0x820
	.hword 0x800, 0x0, 0x820, 0x0, 0x0, 0x0, 0x0, 0x20, 0xe72a, 0xf763
	.hword 0xff61, 0xff60, 0xff60, 0xf760, 0xf780, 0xf780, 0xf760, 0xff60, 0xf760, 0xf760
	.hword 0xf760, 0xf760, 0xf760, 0xf760, 0xf780, 0xf780, 0xf780, 0xf760, 0xf760, 0xf743
	.hword 0xef2a, 0x1020, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20
	.hword 0x840, 0xe72a, 0xf763, 0xff60, 0xff60, 0xff60, 0xf780, 0xf780, 0xf780, 0xf760
	.hword 0xff80, 0xff60, 0xff60, 0xf760, 0xff60, 0xf760, 0xf780, 0xf780, 0xf760, 0xf760
	.hword 0xf760, 0xf743, 0xef2a, 0x820, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x840, 0xef48, 0xf743, 0xff61, 0xff60, 0xf760, 0xf760
	.hword 0xf760, 0xff80, 0xf740, 0xff80, 0xf760, 0xf760, 0xff60, 0xf760, 0xf760, 0xf760
	.hword 0xf760, 0xf780, 0xf780, 0xf743, 0xef2a, 0x840, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x840, 0xe70a, 0xf744, 0xff60
	.hword 0xff60, 0xf760, 0xf780, 0xffa0, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760
	.hword 0xf760, 0xf780, 0xf760, 0xf780, 0xf780, 0xef62, 0xef4a, 0x840, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x860
	.hword 0xef08, 0xf744, 0xff61, 0xf760, 0xf780, 0xf780, 0xf760, 0xff80, 0xf760, 0xf760
	.hword 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf780, 0xf780, 0xef62, 0xef2a, 0x840
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x840, 0xef0a, 0xf723, 0xff80, 0xf780, 0xf780, 0xf760, 0xf740
	.hword 0xf760, 0xf760, 0xff60, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf743
	.hword 0xef2a, 0x820, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x820, 0xef29, 0xf743, 0xf761, 0xff80
	.hword 0xff80, 0xff60, 0xf760, 0xf760, 0xff60, 0xf760, 0xf760, 0xf760, 0xff60, 0xff60
	.hword 0xf760, 0xf743, 0xef2a, 0x820, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x840, 0xef2b
	.hword 0xf764, 0xf740, 0xf740, 0xff60, 0xf760, 0xf780, 0xf760, 0xf760, 0xf760, 0xf760
	.hword 0xf760, 0xf760, 0xf760, 0xf742, 0xef2a, 0x820, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x20, 0x820, 0xef29, 0xff64, 0xff81, 0xf780, 0xf760, 0xf760, 0xf760, 0xf760
	.hword 0xf760, 0xf760, 0xf760, 0xf760, 0xf760, 0xf742, 0xef2a, 0x820, 0x0, 0x0
	.hword 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x820, 0x1020, 0xef0a, 0xef63, 0xf780, 0xf780, 0xff60
	.hword 0xff60, 0xff60, 0xff60, 0xf760, 0xff80, 0xff60, 0xff60, 0xf743, 0xef2a, 0x820
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x1040, 0xef69, 0xef63
	.hword 0xf761, 0xff60, 0xff60, 0xf760, 0xf760, 0xff80, 0xf740, 0xff80, 0xff60, 0xf743
	.hword 0xef2a, 0x840, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x800
	.hword 0x820, 0xef0a, 0xf743, 0xff60, 0xf780, 0xf780, 0xf780, 0xffa0, 0xf760, 0xf760
	.hword 0xf760, 0xf743, 0xef49, 0x840, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x800, 0x1040, 0xef08, 0xf764, 0xf781, 0xf780, 0xf780, 0xf780
	.hword 0xf760, 0xff80, 0xf760, 0xf743, 0xef49, 0x840, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x800, 0x820, 0xe70a, 0xef43, 0xffa0
	.hword 0xf780, 0xf780, 0xf760, 0xf740, 0xf780, 0xef62, 0xef29, 0x840, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x840
	.hword 0xef49, 0xf743, 0xf741, 0xff80, 0xff81, 0xf780, 0xf780, 0xef62, 0xef29, 0x840
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x40, 0x820, 0xef0b, 0xff44, 0xf740, 0xf740, 0xff60, 0xf760, 0xf742
	.hword 0xef49, 0x840, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20
	.hword 0x0, 0x0, 0x0, 0x0, 0x820, 0x820, 0xef29, 0xff64, 0xff81, 0xff60
	.hword 0xff60, 0xf743, 0xef2a, 0x840, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x820, 0x840, 0xe70a
	.hword 0xf763, 0xff60, 0xff60, 0xff63, 0xef09, 0x820, 0x0, 0x1, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x840, 0xef48, 0xf763, 0xf761, 0xf723, 0xef2b, 0x820, 0x20, 0x20
	.hword 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x20, 0x0, 0x820, 0xe72a, 0xf763, 0xf764, 0xe70d, 0x820
	.hword 0x40, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x840, 0xe72a, 0xe72a
	.hword 0x840, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x20, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x20, 0x0, 0x0, 0x0

.align 2
// let mut bulletSkinArray: [&Pixmap; 3];
bulletSkinArray:
	.long bulletSkinLeft
	.long bulletSkinForward
	.long bulletSkinRight

.align 1
bulletSkinLeft:
	.hword 8, 8, 0xfd58
	.hword 0x7eff, 0x7f1f, 0x6f1f, 0x86fe, 0xfd58, 0xfd58, 0xfd58, 0xfd58, 0x7f1f, 0x2496
	.hword 0x24d8, 0x2c95, 0x9ebb, 0xfd58, 0xfd58, 0xfd58, 0x771f, 0x1cb7, 0x14f9, 0x14b7
	.hword 0x8edd, 0xfd58, 0xfd58, 0xfd58, 0x86de, 0x2c75, 0x24f8, 0x24d8, 0x3475, 0x96dc
	.hword 0xfd58, 0xfd58, 0xfd58, 0x9e7b, 0x8ebe, 0x3456, 0x3497, 0x86be, 0xfd58, 0xfd58
	.hword 0xfd58, 0xfd58, 0xfd58, 0x9e9d, 0x8ebf, 0x4435, 0xa67b, 0xfd58, 0xfd58, 0xfd58
	.hword 0xfd58, 0xfd58, 0xfd58, 0xa65b, 0xae9b, 0xfd58, 0xfd58, 0xfd58, 0xfd58, 0xfd58
	.hword 0xfd58, 0xfd58, 0xfd58, 0xae7a


.align 1
bulletSkinForward:
	.hword 8, 8, 0xfd58
	.hword 0xfd58, 0xfd58, 0xfd58, 0x8ede, 0x8ede, 0xfd58, 0xfd58, 0xfd58, 0xfd58, 0xfd58
	.hword 0x86bd, 0x34d7, 0x2c96, 0x8ebe, 0xfd58, 0xfd58, 0xfd58, 0x9ebc, 0x24d8, 0xcfa
	.hword 0xcda, 0x2497, 0x9e9c, 0xfd58, 0xfd58, 0x9e9c, 0x1cb8, 0x51b, 0xd1b, 0x24b9
	.hword 0x965b, 0xfd58, 0xfd58, 0xfd58, 0x7f1f, 0x14d9, 0x1cd9, 0x7edf, 0xfd58, 0xfd58
	.hword 0xfd58, 0xfd58, 0x8ede, 0x34b6, 0x2c55, 0x96bd, 0xfd58, 0xfd58, 0xfd58, 0xfd58
	.hword 0xfd58, 0x4c33, 0xa69c, 0xfd58, 0xfd58, 0xfd58, 0xfd58, 0xfd58, 0xfd58, 0xa67b
	.hword 0xfd58, 0xfd58, 0xfd58, 0xfd58

.align 1
bulletSkinRight:
	.hword 8, 8, 0xfd58
	.hword 0xfd58, 0xfd58, 0xfd58, 0xfd58, 0x86fe, 0x6f1f, 0x7f1f, 0x7eff, 0xfd58, 0xfd58
	.hword 0xfd58, 0x9ebb, 0x2c95, 0x24d8, 0x2496, 0x7f1f, 0xfd58, 0xfd58, 0xfd58, 0x8edd
	.hword 0x14b7, 0x14f9, 0x1cb7, 0x771f, 0xfd58, 0xfd58, 0x96dc, 0x3475, 0x24d8, 0x24f8
	.hword 0x2c75, 0x86de, 0xfd58, 0xfd58, 0x86be, 0x3497, 0x3456, 0x8ebe, 0x9e7b, 0xfd58
	.hword 0xfd58, 0xa67b, 0x4435, 0x8ebf, 0x9e9d, 0xfd58, 0xfd58, 0xfd58, 0xfd58, 0xae9b
	.hword 0xa65b, 0xfd58, 0xfd58, 0xfd58, 0xfd58, 0xfd58, 0xae7a, 0xfd58, 0xfd58, 0xfd58
	.hword 0xfd58, 0xfd58, 0xfd58, 0xfd58
