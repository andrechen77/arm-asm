

.data

// controller interface
.EQU REG_PIX_FRONTBUFFER, 0xff203020 // **PixBuffer
.EQU REG_PIX_BACKBUFFER, 0xff203024 // **PixBuffer
.EQU REG_PIX_STATUS, 0xff20302c

// text buffer address
.EQU TEXT_BUFFER, 0xc9000000 // **TextBuffer

// pushbutton state address
.EQU PUSHBUTTON_STATE, 0xff200050

// screen metadata
.EQU PIX_WIDTH, 320 // uint
.EQU PIX_HEIGHT, 240 // uint
.EQU TEXT_WIDTH, 80 // uint
.EQU TEXT_HEIGHT, 60 // uint

// struct definitions

/*
type TextBuffer = [[u8; TEXT_WIDTH]; TEXT_HEIGHT]; // not a regular array;
// the row index can take up 6 bits, the column index can take up 7 bits
// Interpreting buffer as a pointer, the byte at (r, c) is at `buffer + r << 7 + c`.
// Give it a size of 0x2000 (1 << 13)
}
*/
.EQU TEXTBUFFER_ROWSHIFT, 0x80 // (1 << 7)

/*
type PixBuffer = [[u16; PIX_WIDTH]; PIX_HEIGHT], // not a regular array;
// the row index can take up 8 bits, the column index can take up 9 bits
// Interpreting buffer as a pointer, the color at (r, c) is at `buffer + r << 10 + c << 1`.
// Give it a size of 0x40000 (1 << 18)
}
*/
.EQU PIXBUFFER_SIZE, 0x40000 // (1 << 18)
.EQU PIXBUFFER_ROWSHIFT, 0x400 // (1 << 10)

/*
type ShadowSpace = [[u32; PIX_WIDTH]; PIX_HEIGHT];
*/
.EQU SHADOWSPACE_SIZE, PIX_WIDTH * PIX_HEIGHT

/*
struct Pixmap {
	width: u16,
	height: u16,
	transparency: u16,
	pixelData: [u16; width * height], // variable-length struct
}
*/
.EQU PIXMAP_FIELD_WIDTH, 0
.EQU PIXMAP_FIELD_HEIGHT, 2
.EQU PIXMAP_FIELD_TRANSPARENCY, 4
.EQU PIXMAP_FIELD_PIXELDATA, 6

/*
struct Sprite {
	appearance: *Pixmap,
	xPos: i16,
	yPos: i16,
}
*/
.EQU SPRITE_FIELD_APPEARANCE, 0
.EQU SPRITE_FIELD_XPOS, 4
.EQU SPRITE_FIELD_YPOS, 6
.EQU SPRITE_SIZE, 8

/*
struct Entity extends Sprite {
	xRad: u16
	yRad: u16
	xVel: i8,
	yVel: i8,
	xAccel: i8,
	yAccel: i8,
}
*/
.EQU ENTITY_FIELD_XRAD, 8
.EQU ENTITY_FIELD_YRAD, 10
.EQU ENTITY_FIELD_XVEL, 12
.EQU ENTITY_FIELD_YVEL, 13
.EQU ENTITY_FIELD_XACCEL, 14
.EQU ENTITY_FIELD_YACCEL, 15
.EQU ENTITY_SIZE, 16

// global data

// bufferA: PixBuffer
.align 1
bufferA:
	.skip PIXBUFFER_SIZE

// bufferB: PixBuffer
.align 1
bufferB:
	.skip PIXBUFFER_SIZE

// tick: u32
.align 4
tick:
	.word 0

// entities: Vec<Entity>
.align 2
entities:
	// entities.len
	.word 5
	// entities[0] // player
	.long platformCarrierRight
	.hword 160, 100
	.hword 16, 16
	.byte 0, 10, 0, 1
	// entities[1] // ball
	.long simplePix
	.hword 76, 40
	.hword 4, 4
	.byte 2, 0, 0, 1
	// entities[2] // ball
	.long simplePix
	.hword 154, 40
	.hword 4, 4
	.byte 2, 0, 0, 1
	// entities[3] // ball
	.long simplePix
	.hword 232, 40
	.hword 4, 4
	.byte 2, 0, 0, 1
	// entities[4] // ball
	.long simplePix
	.hword 310, 40
	.hword 4, 4
	.byte 2, 0, 0, 1

// functions
.text

/*
_start
*/
.global _start
_start:
	// initialize stack pointer
	mov sp, #0x800000

	bl setUpDoubleBuffer

	// call main
	bl main

	// idk what to do if execution gets here so just do a useless loop
_start_uselessLoop:
	ror r0, r0, #1
	b _start_uselessLoop
// end _start

/*
main
*/
main:
	push {r4, r5, lr}

	ldr r4, =REG_PIX_BACKBUFFER

	mov r8, #7 // xvel
	mov r9, #0 // yvel
	mov r10, #1 // yacc

main_loop:
	bl waitVsync

	ldr r0, [r4] // r5 is a pointer to the backbuffer
	ldr r1, =entities
	bl renderFrame

	bl swapBuffers

	// calculate next frame
	bl advanceFrame

	b main_loop


	pop {r4, r5, lr}
// end main

/*
advanceFrame: changes the game state to reflect the next frame

advanceFrame() {
	tick += 1;

	movePlayer();

	for entity in entities {
		moveWithBounce(&mut entity);
	}
	processCollisions();
}
*/
advanceFrame:
	push {r4-r6, lr}

	// advance tick
	ldr r0, =tick
	ldr r1, [r0]
	add r1, r1, #1
	str r1, [r0]

	bl movePlayer

	// loop through all entities
	mov r4, #0
	ldr r6, =entities
	ldr r5, [r6], #4
	b advanceFrame_cond
advanceFrame_body:

	add r0, r6, r4, lsl #4
	bl moveWithBounce

	add r4, r4, #1
advanceFrame_cond:
	cmp r4, r5
	blo advanceFrame_body

	// processCollisions();
	bl processCollisions

	pop {r4-r6, pc}
// end advanceFrame

/*
movePlayer: changes the player's velocity and appearance based on the pushbutton states

movePlayer() {
	let player = &entities[0];
	let (right, left, down, up) = getPushbuttonState();
	let xMove = (right as i32) - (left as i32);
	if xMove > 0 {
		player.appearance = platformCarrierRight;
	} else if xMove < 0 {
		player.appearance = platformCarrierLeft;
	}
	player.xVel = xMove * 2;
	let yMove = (down as i32) - (up as i32);
	if player.yPos >= (PIX_HEIGHT - player.yRad) && yMove < 0 {
		player.yVel = -10;
	} else if yMove > 0 {
		player.yVel = 10;
	}
}
*/
movePlayer:
	// r0 = right, r1 = left, r2 = down, r3 = up
	ldr r3, =PUSHBUTTON_STATE
	ldr r3, [r3]
	and r0, r3, #0x1
	and r1, r3, #0x2
	lsr r1, r1, #1
	and r2, r3, #0x4
	lsr r2, r2, #2
	and r3, r3, #0x8
	lsr r3, r3, #3

	// r0 = xMove, r1 = yMove
	sub r0, r0, r1
	sub r1, r2, r3

	// r2 = player
	ldr r2, =entities
	add r2, #4

	// change player costume; r3 = ???
	cmp r0, #0
	bgt movePlayer_changeCostumeRight
	blt movePlayer_changeCostumeLeft
	b movePlayer_changeCostumeDone
movePlayer_changeCostumeRight:
	ldr r3, =platformCarrierRight
	str r3, [r2, #SPRITE_FIELD_APPEARANCE]
	b movePlayer_changeCostumeDone
movePlayer_changeCostumeLeft:
	ldr r3, =platformCarrierLeft
	str r3, [r2, #SPRITE_FIELD_APPEARANCE]
movePlayer_changeCostumeDone:

	// player.xVel = xMove * 2; r3 = ???, r0 = ???
	mov r3, #2
	mul r0, r0, r3
	strb r0, [r2, #ENTITY_FIELD_XVEL]


	// handle yVel
	ldrh r0, [r2, #SPRITE_FIELD_YPOS]
	cmp r0, #204 // hardcoded
	blt movePlayer_else
	cmp r1, #0
	bge movePlayer_else

	// then block
	mov r0, #-10
	strb r0, [r2, #ENTITY_FIELD_YVEL]

	b movePlayer_done
movePlayer_else:
	cmp r1, #0
	ble movePlayer_done
	mov r0, #10
	strb r0, [r2, #ENTITY_FIELD_YVEL]

movePlayer_done:

	bx lr
// end movePlayer

/*
processCollisions: makes colliding sprites interact. If a player hits a ball, the ball gets "caught"
by the player and is given twice player's upward velocity. The player then loses all upward velocity.
Balls pass through each other

processCollisions() {
	let player = entities[0];
	for ball in entities[1..] {
		if checkCollision(player, ball) {
			ball.yPos = player.yPos - player.yRad - ball.yRad;
			ball.yVel = min(0, player.yVel * 2);
			player.yVel = 0;
		}
	}
}
*/
processCollisions:
	push {r4-r5, lr}

	// r4 = &entities[0], r5 = &entities[entities.len]
	ldr r4, =entities
	ldr r5, [r4]
	add r4, #4
	mov r0, #ENTITY_SIZE
	mla r5, r5, r0, r4

	// r5 = entities[i]
	b processCollisions_cond
processCollisions_body:

	mov r0, r4
	mov r1, r5
	bl checkCollision
	cmp r0, #0
	beq processCollisions_cond

	// ball.yPos = player.yPos - player.yRad - ball.yRad;
	ldrh r0, [r4, #SPRITE_FIELD_YPOS]
	ldrh r1, [r4, #ENTITY_FIELD_YRAD]
	sub r0, r0, r1
	ldrh r1, [r5, #ENTITY_FIELD_YRAD]
	sub r0, r0, r1
	strh r0, [r5, #SPRITE_FIELD_YPOS]

	// ball.yVel = min(0, player.yVel * 2);
	ldrsb r0, [r4, #ENTITY_FIELD_YVEL]
	add r0, r0, r0
	cmp r0, #0
	movgt r0, #0
	strb r0, [r5, #ENTITY_FIELD_YVEL]

	// player.yVel = 0;
	mov r0, #0
	strb r0, [r4, #ENTITY_FIELD_YVEL]

processCollisions_cond:
	sub r5, #ENTITY_SIZE
	cmp r5, r4
	bgt processCollisions_body

	pop {r4-r5, pc}
// end processCollisions

/*
checkCollision(a: *Entity, b: *Entity) -> bool {
	let dx = b.x - a.x;
	let collisionDx = max(a.xRad, b.xRad);

	let dy = b.y - a.y;
	let collisionDy = max(a.yRad, b.yRad);

	return abs(dx) <= collisionDx && abs(dy) <= collisionDy;
}
*/
checkCollision:
	push {r4}

	// r0 = a
	// r1 = b

	// r2 = abs(dx)
	ldrh r2, [r0, #SPRITE_FIELD_XPOS]
	ldrh r3, [r1, #SPRITE_FIELD_XPOS]
	subs r2, r3, r2
	rsblt r2, r2, #0

	// r3 = collisionDx
	ldrh r3, [r0, #ENTITY_FIELD_XRAD]
	ldrh r4, [r1, #ENTITY_FIELD_XRAD]
	cmp r3, r4
	movlt r3, r4

	// early return false if x does not collide
	cmp r2, r3
	bgt checkCollision_noCollision

	// r2 = abs(dy)
	ldrh r2, [r0, #SPRITE_FIELD_YPOS]
	ldrh r3, [r1, #SPRITE_FIELD_YPOS]
	subs r2, r3, r2
	rsblt r2, r2, #0

	// r3 = collisionDy
	ldrh r3, [r0, #ENTITY_FIELD_YRAD]
	ldrh r4, [r1, #ENTITY_FIELD_YRAD]
	cmp r3, r4
	movlt r3, r4

	// return false if y does not collide
	cmp r2, r3
	bgt checkCollision_noCollision

	// they must collide
	mov r0, #1
	pop {r4}
	bx lr

checkCollision_noCollision:
	mov r0, #0
	pop {r4}
	bx lr
// end checkCollision

/*
moveWithBounce: moves the entity according to its velocity and acceleration, bouncing when it hits a
wall. Loses all velocity when it hits a floor. Returns whether a collision occured.

moveWithBounce(entity: *Entity) -> bool {
	let mut bounced = false;

	let (xMin, xMax) = (entity.xRad, PIX_WIDTH - entity.xRad);
	entity.xPos += entity.xVel;
	if (entity.xPos <= xMin || entity.xPos >= xMax) {
		if (entity.xPos <= xMin) {
			entity.xPos = xMin;
		}
		if (entity.xPos >= xMax) {
			entity.xPos = xMax;
		}
		bounced = true;
		entity.xVel = -entity.xVel;
	} else {
		entity.xVel += entity.xAccel;
	}

	let (yMin, yMax) = (entity.yRad, PIX_HEIGHT - entity.yRad);
	entity.yPos += entity.yVel;
	if (entity.yPos <= yMin || entity.yPos >= yMax) {
		if (entity.yPos <= yMin) {
			entity.yPos = yMin;
		}
		if (entity.yPos >= yMax) {
			entity.yPos = yMax;
		}
		bounced = true;
		entity.yVel = 0;
	}
	entity.yVel += entity.yAccel;

	return bounced;
}
*/
moveWithBounce:
	push {r4-r7}

	// r0 = entity

	// r1 = bounced
	mov r1, #0

	// (r2, r3) = (xMin, xMax)
	ldrh r2, [r0, #ENTITY_FIELD_XRAD]
	rsb r3, r2, #PIX_WIDTH

	// r4 = entity.xPos, r5 = entity.xVel
	ldrh r4, [r0, #SPRITE_FIELD_XPOS]
	ldrsb r5, [r0, #ENTITY_FIELD_XVEL]

	add r4, r4, r5
	cmp r4, r2
	movle r4, r2
	ble moveWithBounce_bounceX
	cmp r4, r3
	movge r4, r3
	bge moveWithBounce_bounceX
	ldrsb r2, [r0, #ENTITY_FIELD_XACCEL]
	add r5, r5, r2
	b moveWithBounce_xDone
moveWithBounce_bounceX:
	mov r1, #1
	rsb r5, r5, #0
moveWithBounce_xDone:

	// (r2, r3) = (xMin, xMax)
	ldrh r2, [r0, #ENTITY_FIELD_YRAD]
	rsb r3, r2, #PIX_HEIGHT

	// r6 = entity.yPos, r7 = entity.yVel
	ldrh r6, [r0, #SPRITE_FIELD_YPOS]
	ldrsb r7, [r0, #ENTITY_FIELD_YVEL]

	add r6, r6, r7
	cmp r6, r2
	movle r6, r2
	ble moveWithBounce_bounceY
	cmp r6, r3
	movge r6, r3
	bge moveWithBounce_bounceY
	b moveWithBounce_yDone
moveWithBounce_bounceY:
	mov r1, #1
	mov r7, #0
moveWithBounce_yDone:
	ldrsb r2, [r0, #ENTITY_FIELD_YACCEL]
	add r7, r7, r2

	// restore the fields in memory
	strh r4, [r0, #SPRITE_FIELD_XPOS]
	strb r5, [r0, #ENTITY_FIELD_XVEL]
	strh r6, [r0, #SPRITE_FIELD_YPOS]
	strb r7, [r0, #ENTITY_FIELD_YVEL]

	// return whether it bounced
	mov r0, r1

	pop {r4-r7}
	bx lr
// end moveWithBounce

/*
renderFrame(buffer: *PixBuffer, entities: *Vec<Entity>) {
	clearVga();
	for entity in entities {
		bitBlit(buffer, entity.sprite, entity.sprite.xPos, entity.sprite.yPos);
	}
	clearTextBuffer();
	drawNum(0, 0, tick);
	drawStr(15, 10, "Pushbuttons: up/down/left/right. Keep the ball up!");
}
*/
renderFrame:
	push {r4-r7, lr}
	// r0 = buffer
	// r1 = entities

	// r4 = buffer
	mov r4, r0
	// r5 = entities.data
	add r5, r1, #4

	// clearVga();
	// r0 is already the buffer address
	ldr r1, =0x0
	bl clearVga

	// loop from 0 to entities.len
	mov r6, #0
	ldr r7, [r5, #-4]
	b renderFrame_cond
renderFrame_body:

	// bitBlit(buffer, entity, entity,xPos, entity.yPos)
	mov r0, r4
	add r1, r5, r6, lsl #4
	ldrh r2, [r1, #SPRITE_FIELD_XPOS]
	ldrh r3, [r1, #SPRITE_FIELD_YPOS]
	ldr r1, [r1, #SPRITE_FIELD_APPEARANCE]
	bl bitBlit

	add r6, r6, #1
renderFrame_cond:
	cmp r6, r7
	blo renderFrame_body

	bl clearTextBuffer

	// drawNum(0, 0, tick)
	mov r0, #0
	mov r1, #0
	ldr r2, =tick
	ldr r2, [r2]
	bl drawNum

	// drawStr(...)
	mov r0, #15
	mov r1, #10
	ldr r2, =helpMessage
	bl drawStr
.data
helpMessage:
	.asciz "Pushbuttons: up/down/left/right. Keep the ball up!"
.text

	pop {r4-r7, pc}
// end renderFrame

/*
setUpDoubleBuffer
*/
setUpDoubleBuffer:
	push {r4, lr}

	ldr r4, =REG_PIX_BACKBUFFER

	// put the buffer address into the backbuffer register
	ldr r0, =bufferA
	str r0, [r4]

	bl swapBuffers
	bl waitVsync

	// put the other buffer address into the backbuffer register
	ldr r0, =bufferB
	str r0, [r4]

	pop {r4, pc}
// end setUpDoubleBuffer

/*
swapBuffers: requests a buffer swap by writing 1 to the frontbuffer register
*/
swapBuffers:
	mov r0, #1
	ldr r1, =REG_PIX_FRONTBUFFER
	str r0, [r1]
	bx lr
// end swapBuffers

/*
waitVsync: blocks until vsync is finished
*/
waitVsync:
	ldr r0, =REG_PIX_STATUS
	ldr r0, [r0]
	and r0, r0, #0x1
	cmp r0, #0
	bne waitVsync
	bx lr
// end waitVsync

/*
clearVga: Fills the video buffer with the specified color

clearVga(buffer: *PixBuffer, color: u16) {
	let color_pair: u32 = (color << 16) | color;
	for row in 0..240 {
		let buffer_row = buffer[row] as *u32; // expand size to write to 4-byte color pairs rather than 2-byte colors
		for col in 0..(320 / 2) { // col doesn't count pixels, but rather pixel pairs
			buffer[col] = colorpair;
		}
	}
}
*/
clearVga:
	// r0 = buffer_row (see outer loop's iteration expression)

	// r1 = colorpair
	orr r1, r1, r1, lsl #16

	// r2 = row
	mov r2, #0
	b clearVga_outerForCond
clearVga_outerForBody:

	// r3 = col
	mov r3, #0
	b clearVga_innerForCond
clearVga_innerForBody:

	str r1, [r0, r3, lsl #2] // storing into a u32 array

	add r3, r3, #1
clearVga_innerForCond:
	cmp r3, #(PIX_WIDTH / 2)
	blo clearVga_innerForBody

	add r2, r2, #1
	add r0, r0, #PIXBUFFER_ROWSHIFT // update pointer to new row
clearVga_outerForCond:
	cmp r2, #PIX_HEIGHT
	blo clearVga_outerForBody

	bx lr
// end clearVga

/*
clearTextBuffer: Fills the text buffer with spaces (ASCII 32)
clearTextBuffer() {
	for row in 0..60 {
		let buffer_row = TEXT_BUFFER[row];
		for col in (0..80).step(4) {
			// expand size to write 4-byte strings rather than single byte characters
			*(buffer_row[col] as *u32) = 0x20202020;
		}
	}
}
*/
clearTextBuffer:
	// r0 = buffer_row (see outer loop's iteration expression)
	mov r0, #TEXT_BUFFER

	// r1 = 0x20202020
	ldr r1, =0x20202020

	// r2 = row
	mov r2, #0
	b clearTextBuffer_outerForCond
clearTextBuffer_outerForBody:

	// r3 = col
	mov r3, #0
	b clearTextBuffer_innerForCond
clearTextBuffer_innerForBody:

	str r1, [r0, r3]

	add r3, r3, #4
clearTextBuffer_innerForCond:
	cmp r3, #TEXT_WIDTH
	blo clearTextBuffer_innerForBody

	add r2, r2, #1
	add r0, r0, #TEXTBUFFER_ROWSHIFT // update pointer to new row
clearTextBuffer_outerForCond:
	cmp r2, #TEXT_HEIGHT
	blo clearTextBuffer_outerForBody

	bx lr
// end clearTextBuffer

/*
bitBlit: Draws the specified Pixmap into the VGA buffer, centered at the specified x and y
coordinates. If the image goes past the VGA screen boundaries, pixels are not drawn.

Pseudocode:
bitBlit(buffer: *PixBuffer, p: *Pixmap, x: i32, y: i32) {
	// convert center coordinates to top left corner coordinates
	let y = y - p.height >> 1;
	let x = x - p.width >> 1;

	// find the portion of the pixmap to draw
	let start_row = max(0, -y);
	let start_col = max(0, -x);
	let end_row = min(p.height, PIX_HEIGHT - y);
	let end_col = min(p.width, PIX_WIDTH - x);

	for row in start_row..end_row {
		let buffer_row: *u16 = (buffer[y + row] + x) as *u16;
		for col in start_col..end_col {
			let pixel = p.pixeldata[row * p.width + col];
			if pixel != p.transparency {
				buffer[col] = pixel;
			}
		}
	}
}
*/
bitBlit:
	push {r4-r9, lr}

	// r0 = buffer
	// r1 = p
	// r2 = x
	// r3 = y

	// r4 = p.width
	ldrh r4, [r1, #PIXMAP_FIELD_WIDTH]

	// r5 = p.height
	ldrh r5, [r1, #PIXMAP_FIELD_HEIGHT]

	// r2 = x
	sub r2, r2, r4, lsr #1

	// r3 = y
	sub r3, r3, r5, lsr #1

	// r6 = start_col
	rsb r6, r2, #0
	cmp r6, #0
	bgt bitBlit_1
	mov r6, #0
bitBlit_1:

	// r7 = start_row
	rsb r7, r3, #0
	cmp r7, #0
	bgt bitBlit_0
	mov r7, #0
bitBlit_0:

	// r8 = end_col
	rsb r8, r2, #PIX_WIDTH
	cmp r8, r4
	blt bitBlit_3
	mov r8, r4
bitBlit_3:

	// r9 = end_row
	rsb r9, r3, #PIX_HEIGHT
	cmp r9, r5
	blt bitBlit_2
	mov r9, r5
bitBlit_2:

	// From here on, horizontal coordinates are double what they are in the pseudocode, for ease of
	// fetching the halfword values.
	lsl r2, r2, #1
	lsl r4, r4, #1
	lsl r8, r8, #1
	// skip doubling r6 because it gets reset anyway

	// r0 = PIX_BUFFER[y + start_row] + x
	add r0, r0, r3, lsl #10
	add r0, r0, r7, lsl #10
	add r0, r0, r2

	// r3 = p.transparency
	ldrh r3, [r1, #PIXMAP_FIELD_TRANSPARENCY]

	// r1 = p.pixeldata
	add r1, #PIXMAP_FIELD_PIXELDATA

	// r2 = start_col
	lsl r2, r6, #1

	// r7 = row
	// r6 = col

	// outer for loop
	b bitBlit_outerCond
bitBlit_outerBody:

	// r0 = buffer_row (see loop's iteration expression)

	// inner for loop
	mov r6, r2
	b bitBlit_innerCond
bitBlit_innerBody:

	// r5 = pixel
	mla r5, r7, r4, r6
	ldrh r5, [r1, r5]

	// maybe draw pixel
	cmp r5, r3
	beq bitBlit_skipDraw
	strh r5, [r0, r6]
bitBlit_skipDraw:

	add r6, r6, #2
bitBlit_innerCond:
	cmp r6, r8
	blt bitBlit_innerBody

	add r0, r0, #0x400 // update pointer to new row (0x400 is 1 << 10)
	add r7, r7, #1
bitBlit_outerCond:
	cmp r7, r9
	blt bitBlit_outerBody

	pop {r4-r9, pc}
// end bitBlit

/*
drawStr: draws a null-terminated string into the character buffer

drawStr(x: uint, y: uint, str: *char) {
	let bufferRow: [u8; TEXT_WIDTH] = TEXT_BUFFER[y];
	let mut col = x;
	let mut p = str;
	while x < TEXT_WIDTH && *p != '\0' {
		bufferRow[col] = *p;
		col += 1;
		p += 1;
	}
}
*/
drawStr:
	// r0 = x
	// r1 = y
	// r2 = str

	// r1 = bufferRow
	lsl r1, r1, #7
	add r1, r1, #TEXT_BUFFER

	// r0 = col
	// r3 = *p
	b drawStr_cond
drawStr_loop:

	strb r3, [r1, r0]
	add r0, r0, #1
	add r2, r2, #1

drawStr_cond:
	cmp r0, #TEXT_WIDTH
	bhs drawStr_end
	ldrb r3, [r2]
	cmp r3, #0
	bne drawStr_loop

drawStr_end:
	bx lr
// end drawStr

/*
drawNum: draws a signed integer into the character buffer

drawNum(x: uint, y: uint, num: i32) {
	let mut remainingDigits = num;
	let mut buffer: [u8; 12]; // max int is 10 decimal digits, plus two for null terminator and minus
	let mut = 11; // index to the first element of the array
	buffer[index] = '\0';

	// add digits to buffer
	if num == 0 {
		index -= 1;
		buffer[index] = '0';
	} else {
		// handle negative
		if num < 0 {
			remainingDigits = -remainingDigits;
		}

		// extract digits
		let mut rem;
		// write to the array from right to left
		while remainingDigits > 0 {
			(remainingDigits, rem) = divTenRem(remainingDigits);
			index -= 1;
			buffer[index] = toAscii(rem);
		}

		if num < 0 {
			index -= 1;
			buffer[index] = '-';
		}
	}

	// print buffer
	drawStr(x, y, (buffer as *u8) + index);
}
*/
drawNum:
	push {r4-r7, lr}

	// sp = buffer
	sub sp, sp, #12

	// r4 = x, r5 = y, r6 = num, r7 = index
	mov r4, r0
	mov r5, r1
	mov r6, r2
	mov r7, #11

	// buffer[index] = '\0';
	mov r0, #0
	strb r0, [sp, r7]

	// r0 = num, r0 = remainingDigits
	movs r0, r2

	// handle zero
	beq drawNum_isZero

	// handle negative possibility
	rsblt r0, r0, #0

	// extract digits
	b drawNum_cond
drawNum_loop:

	// r0 = remainingDigits, r1 = rem
	bl divTenRem
	sub r7, r7, #1
	add r1, r1, #48 // r1 = toAscii(rem)
	strb r1, [sp, r7]

drawNum_cond:
	cmp r0, #0
	bhi drawNum_loop

	// maybe add minus sign
	cmp r6, #0
	bge drawNum_skipMinusSign
	sub r7, r7, #1
	mov r1, #45 // r1: '-'
	strb r1, [sp, r7]
drawNum_skipMinusSign:

	b drawNum_print
drawNum_isZero:
	sub r7, r7, #1
	mov r1, #48 // r1 = '0'
	strb r1, [sp, r7]

drawNum_print:
	mov r0, r4
	mov r1, r5
	add r2, sp, r7
	bl drawStr

	add sp, sp, #12 // deallocate array of 12 bytes
	pop {r4-r7, pc}
// end drawNum

/*
divTenRemSmall

Divides an unsigned number by 10, returning its quotient and remainder. Will not work for numbers
larger than about 6.7e8.
Algorithm for dividing by 10 credited to:
Vowels, R. A. (1992). "Division by 10". Australian Computer Journal. 24 (3): 81â€“85.

Parameters:
	r0: int dividend
Returns:
	r0: int quotient
	r1: int remainder
*/
divTenRemSmall:
	mov r1, r0 // save the divident for later

	// divide r0 by 10
	add r0, r0, #1
	lsl r0, r0, #1
	add r0, r0, r0, lsl #1
	add r0, r0, r0, lsr #4
	add r0, r0, r0, lsr #8
	add r0, r0, r0, lsr #16
	lsr r0, r0, #6

	// subtract quotient * 10 from the dividend to get remainder
	sub r1, r1, r0, lsl #3 // divident - 8 * quotient
	sub r1, r1, r0, lsl #1 // divident - 8 * quotient - 2 * quotient

	bx lr
// end divTenRemSmall

/*
divTenRem

Divides an unsigned number by 10, returning its quotient and remainder. Will work for any unsigned
32-bit number, unlike divTenRemSmall.

Parameters:
	r0: int dividend
Returns:
	r0: int quotient
	r1: int remainder

Pseudocode:
if (dividend <= 0x10000000) { // 28 bits is safely below the maximum valid input for divTenRemSmall
	return divTenRemSmall(dividend);
}
int msn = dividend & 0xf0000000; // "most significant nybble"
int rest = dividend - msn;
msn >>= 4;
(int msnQuot, int msnRem) = divTenRemSmall(msn);
msnQuot <<= 4;
rest += msnRem << 4;
(int restQuot, int restRem) = divTenRemSmall(rest);
return (msnQuot + restQuot, restRem);
*/
divTenRem:
	// r0: dividend
	cmp r0, #0x10000000
	bhi divTenRem_continue
	push {lr}
	bl divTenRemSmall
	pop {pc}

	divTenRem_continue:
	push {r4, r5, lr}
	and r4, r0, #0xf0000000 // r4: msn
	sub r5, r0, r4 // r5: rest
	lsr r0, r4, #4 // r0: msn
	bl divTenRemSmall // r0: msnQuot, r1: msnRem
	lsl r4, r0, #4 // r4: msnQuot
	add r0, r5, r1, lsl $4 // r0: rest
	bl divTenRemSmall // r0: restQuot, r1: restRem
	add r0, r0, r4 // r0: msnQuot + restQuot
	pop {r4, r5, pc}
// end divTenRem

// assets
.data

.align 1
simplePix:
	.hword 8, 8, 0xfffe
	.hword 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4
	.hword 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4
	.hword 0xc4c4, 0xc4c4, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xc4c4, 0xc4c4
	.hword 0xc4c4, 0xc4c4, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xc4c4, 0xc4c4
	.hword 0xc4c4, 0xc4c4, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xc4c4, 0xc4c4
	.hword 0xc4c4, 0xc4c4, 0xfffe, 0xfffe, 0xfffe, 0xfffe, 0xc4c4, 0xc4c4
	.hword 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4
	.hword 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4, 0xc4c4

.align 1
platformCarrierLeft:
	.hword 32, 32, 0x9c80
	.hword 0x9c80, 0xef0c, 0x1020, 0xe6d2, 0xe6d5, 0x0, 0x840, 0xdef3, 0xdef3, 0x20
	.hword 0x820, 0xded3, 0xdef3, 0x840, 0x20, 0xdef4, 0xdef4, 0x20, 0x820, 0xdef3
	.hword 0xdef3, 0x820, 0x840, 0xdef3, 0xdef3, 0x20, 0x0, 0xded4, 0xe6f3, 0x1020
	.hword 0xef0c, 0x9c80, 0xa462, 0xf6cc, 0x1820, 0x1000, 0x1020, 0x1020, 0x820, 0x820
	.hword 0x1020, 0x1040, 0x1020, 0x1020, 0x1020, 0x1020, 0x820, 0x820, 0x820, 0x1040
	.hword 0x1020, 0x1020, 0x1020, 0x1040, 0x1020, 0x820, 0x820, 0x820, 0x1040, 0x1020
	.hword 0x1000, 0x1800, 0xf6cc, 0xa462, 0xb404, 0xfeae, 0xfecd, 0xfecc, 0xf6cb, 0xf6ec
	.hword 0xf6ed, 0xf6ed, 0xf6cc, 0xf6ec, 0xf6cc, 0xf6ec, 0xf6ec, 0xf6ed, 0xf6cc, 0xf6ed
	.hword 0xf6cd, 0xf6ed, 0xf6ec, 0xf6ec, 0xfeec, 0xf6ec, 0xf6ec, 0xf6cc, 0xf6cd, 0xf6ed
	.hword 0xf6cc, 0xf6ec, 0xfecb, 0xfecc, 0xfece, 0xb404, 0xabe9, 0xac07, 0xa424, 0xa443
	.hword 0xa463, 0xa463, 0xa444, 0x9c44, 0xac85, 0xa444, 0xa443, 0xa443, 0xac65, 0xa444
	.hword 0xa444, 0xa444, 0xa465, 0xa424, 0xa444, 0xac44, 0xa444, 0xa444, 0x9c23, 0xa465
	.hword 0xa445, 0xa465, 0xa463, 0xa443, 0xac64, 0xa424, 0xac07, 0xabe8, 0x800, 0x1000
	.hword 0x800, 0x800, 0x800, 0xfffa, 0xfffb, 0xfffb, 0xffda, 0xffda, 0x800, 0x1020
	.hword 0x800, 0x800, 0x800, 0x800, 0x800, 0x800, 0xffda, 0xfffb, 0x800, 0x800
	.hword 0x1020, 0x800, 0x0, 0x820, 0x0, 0x0, 0x800, 0x800, 0x800, 0x800
	.hword 0x0, 0x0, 0x0, 0x0, 0xf7fe, 0xf7fe, 0xf7de, 0xf7ff, 0xffdf, 0xffdf
	.hword 0xffbe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffdf, 0xffde
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x20, 0x0, 0xf7ff, 0xf7ff, 0xf7fe, 0x0, 0x0
	.hword 0x0, 0xffdf, 0xffdf, 0xffdf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0xfffe, 0xffde, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xf7fe, 0xf7fe, 0xf7fe
	.hword 0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xf7ff, 0xf7de, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0xffdf, 0xffdf, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0xf7de, 0xffdf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0xf7ff
	.hword 0xf7ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7df, 0xffdf, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0xf7fe, 0xf7fe, 0xf7de, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0xf7fe, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xf7df
	.hword 0x0, 0x0, 0x0, 0x0, 0xf7fe, 0xf7de, 0xf7ff, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0xfffe, 0xffff, 0xf7df, 0x0, 0x0, 0x0, 0xf7de
	.hword 0xffff, 0xffdf, 0x0, 0x0, 0x0, 0xf7fd, 0xf7fe, 0xf7fe, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffdf, 0xf7df, 0xf7df, 0xffde
	.hword 0xfffe, 0xf7de, 0xffff, 0xf7be, 0xf7df, 0x0, 0xefbd, 0xf7fe, 0xf7fe, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfffe
	.hword 0xf7be, 0xffdf, 0xf7df, 0xf7df, 0x0, 0xf7df, 0xffff, 0xffff, 0xffff, 0xf7fe
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0xfffe, 0xf7de, 0xffdf, 0xf7df, 0xf7bf, 0x0, 0x1, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0xf7de, 0xf7be
	.hword 0xffdf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de
	.hword 0xffdf, 0xffdf, 0xffdf, 0xffdf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x820, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0
	.hword 0xf7de, 0xffff, 0xffdf, 0x0, 0xffdf, 0xffdf, 0xffdf, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0xf7de, 0xffff, 0xf7de, 0x0, 0x0, 0x0, 0xf7de, 0xffdf, 0xf7de
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0xf7de, 0xffff, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0xffff, 0xf7de, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffff
	.hword 0xf7de, 0xf7de, 0xffff, 0xf7be, 0xf7de, 0xffff, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0xf7de, 0xffff, 0xffff, 0x0, 0x20, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0xffff, 0xffff, 0xf7de, 0xf7de, 0xffff, 0xffff, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xffff, 0xf7de, 0xf7de, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffff, 0xffff, 0xf7de, 0xffff
	.hword 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffff, 0xffff, 0xf7de
	.hword 0x0, 0xffff, 0xffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffff, 0xffff
	.hword 0xffff, 0xffff, 0xf7be, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xf7de
	.hword 0xffff, 0x0, 0x0, 0xf7de, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de
	.hword 0xffff, 0xf7de, 0x0, 0x0, 0x0, 0xffff, 0xffff, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0xffff, 0xf7de, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0xffff, 0xf7de, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0xf7de, 0xffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffff
	.hword 0xffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x20, 0xf7de, 0xf7de, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0xf7de, 0xf7de, 0xffff, 0x0, 0x0, 0x0, 0xffff, 0xffff, 0xf7de
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xffff, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0xffff, 0xf7de, 0xffff, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffff, 0xffff
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffff, 0xf7de, 0xf7de
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20
	.hword 0xf7de, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0
	.hword 0xf7be, 0xffff, 0xffff, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0xffff, 0xffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0xffff, 0xffff, 0xf7de, 0x0, 0x20, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0xffff, 0xffff, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffff, 0xf7de, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0

.align 1
platformCarrierRight:
	.hword 32, 32, 0x9c80
	.hword 0x9c80, 0xef0e, 0x2040, 0xe6b8, 0xde79, 0x800, 0x820, 0xded7, 0xded7, 0x820
	.hword 0x800, 0xdeb9, 0xded8, 0x820, 0x820, 0xdeb8, 0xd6b8, 0x840, 0x840, 0xded8
	.hword 0xde98, 0x820, 0x820, 0xdef7, 0xd6b6, 0x1060, 0x800, 0xde99, 0xe698, 0x1840
	.hword 0xef0f, 0x9c81, 0xa483, 0xeece, 0x2040, 0x1800, 0x1840, 0x1860, 0x1040, 0x1040
	.hword 0x1040, 0x1040, 0x1860, 0x1020, 0x1040, 0x1020, 0x1880, 0x820, 0x1040, 0x1060
	.hword 0x1040, 0x1040, 0x1840, 0x1040, 0x1840, 0x1040, 0x1060, 0x1040, 0x1040, 0x1840
	.hword 0x1820, 0x2040, 0xeeae, 0xa483, 0xa404, 0xf68f, 0xf6d0, 0xf6d0, 0xeed0, 0xeeaf
	.hword 0xeef0, 0xeeef, 0xeed0, 0xeed0, 0xeecf, 0xf6f0, 0xf6ef, 0xeecf, 0xeef0, 0xeed0
	.hword 0xeef0, 0xeeaf, 0xf6ef, 0xf6f0, 0xeed0, 0xeed0, 0xeed0, 0xeecf, 0xeeef, 0xeeef
	.hword 0xeef0, 0xeecf, 0xf6d0, 0xf6cf, 0xf68e, 0xac24, 0xac09, 0xa408, 0x9c27, 0xa467
	.hword 0x9c46, 0x9c66, 0x9c66, 0x9c67, 0xa467, 0x9405, 0x9c46, 0xa446, 0xa446, 0x9c46
	.hword 0x9c26, 0xa467, 0x9c66, 0x9c46, 0x9c46, 0xa446, 0x9c26, 0x9c26, 0x9c46, 0xa487
	.hword 0x9c66, 0x9c66, 0x9c86, 0x9c65, 0x9c46, 0x9c26, 0xa407, 0xac29, 0x1000, 0x1000
	.hword 0x1020, 0x820, 0x820, 0x820, 0x840, 0x800, 0x800, 0x1020, 0x1000, 0x1020
	.hword 0xffda, 0xffda, 0x1020, 0x800, 0x800, 0x1020, 0x1000, 0x800, 0x1840, 0x800
	.hword 0xffda, 0xffd9, 0xffd9, 0xffd9, 0xffd9, 0x820, 0x1040, 0x1020, 0x1000, 0x1000
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x800, 0x0, 0xffbd, 0xffdd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x800, 0xff9d, 0xffdd, 0xffdd, 0xfffd, 0xf7dd, 0xfffd, 0xfffe, 0x0, 0x0
	.hword 0x0, 0x0, 0x20, 0x0, 0x0, 0x21, 0xf7df, 0xf7ff, 0xf7ff, 0xf7df
	.hword 0x1, 0x1, 0x0, 0x0, 0xf7dd, 0xfffe, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0xffdf, 0xffdf, 0xffdf, 0x20, 0x0, 0x0, 0xf7fe, 0xf7de
	.hword 0xf7be, 0x0, 0x860, 0x0, 0x0, 0x21, 0x1, 0x1, 0x0, 0x0
	.hword 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0xf7fe, 0xf7fe, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0xffdf, 0xffdf, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0xf7df, 0xf7ff, 0x21, 0x0, 0x0, 0x1, 0x0, 0x21, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0xf7dd, 0xf7fe
	.hword 0xf7fe, 0x0, 0x20, 0x0, 0x0, 0x0, 0xffdf, 0xf7de, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0xf7ff, 0xf7fe, 0x0, 0x0, 0x1, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x20, 0xf7fe, 0xefde, 0xf7fe, 0x0, 0x20, 0x0, 0x0, 0xf7de, 0xf7dd
	.hword 0x20, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xf7de, 0x0, 0x0, 0x1
	.hword 0x0, 0x20, 0x20, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0xf7ff, 0xf7de, 0xf7fe, 0x0, 0x0, 0x0
	.hword 0xffff, 0xfffe, 0xf7dd, 0x0, 0x0, 0x0, 0xf7df, 0xffdf, 0xfffe, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7ff, 0xf7de, 0xef9d
	.hword 0x0, 0xf7bf, 0xf7be, 0xfffe, 0xf7dd, 0xfffe, 0xffde, 0xffdf, 0xffdf, 0xffdf
	.hword 0x0, 0x0, 0x0, 0x0, 0x1, 0xf7bf, 0xffde, 0xffde, 0xffbd, 0xffde
	.hword 0x0, 0x0, 0x1, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0xf7de, 0xfffe, 0xffff, 0xffdf, 0xf7df, 0x0, 0xffde, 0xffdf, 0xffdf, 0xf7be
	.hword 0xffdf, 0x0, 0x0, 0x0, 0x21, 0x0, 0x1, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0xfffe, 0xf7be, 0xf7de, 0x20, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x21, 0x0, 0x20
	.hword 0x0, 0x0, 0x840, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0xffdf, 0xf7de, 0xffff, 0xffff, 0xf7de, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0xffdf, 0xffdf, 0xf7de, 0x0, 0xffff
	.hword 0xf7ff, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x20
	.hword 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xffff, 0xf7de, 0x0
	.hword 0x0, 0x0, 0xf7de, 0xf7ff, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xf7de, 0xf7de
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xffff, 0xf7de, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0xffff, 0xffff
	.hword 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0xffff, 0xf7de
	.hword 0xf7be, 0xffff, 0xf7de, 0xf7de, 0xffff, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de
	.hword 0xf7be, 0xffff, 0xffff, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0
	.hword 0x0, 0xffff, 0xffff, 0xf7de, 0xf7de, 0xffff, 0xffff, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0xf7de, 0xffff, 0xf7de, 0xffff, 0xffff, 0x0, 0x20, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0xf7be, 0xf7de, 0xffff, 0xf7de, 0xffff, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0xffff, 0xffff, 0x0, 0xf7de, 0xf7de, 0xffff, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xf7de, 0x0, 0x0, 0xffff
	.hword 0xf7de, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffff, 0xf7de, 0x0
	.hword 0x20, 0x0, 0xf7de, 0xffff, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de
	.hword 0xffff, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xf7de, 0xffff, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0xffff, 0xffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffff, 0xf7de
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xf7de, 0xffff, 0x0
	.hword 0x0, 0x0, 0xffff, 0xf7de, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x20
	.hword 0xf7de, 0xf7de, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0xffff, 0xf7de, 0xf7de, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0xffff, 0xf7de, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x0, 0x0, 0xf7de, 0xf7de, 0xffff, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0xffff, 0xf7de, 0x0, 0x20, 0x20, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x20, 0x0, 0x0, 0x0, 0xf7de, 0xffff, 0xf7be, 0x0, 0x0
	.hword 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7be, 0xf7de, 0x20, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0xf7de, 0xffff, 0xffff, 0x0
	.hword 0x20, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0xffff, 0xffff
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf7de, 0xf7de
	.hword 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0xf7de, 0xffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
	.hword 0x0, 0x0, 0x0, 0x0